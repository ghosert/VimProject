# Use the official Node.js 18 image from Docker Hub with Alpine Linux as the base
FROM node:18-alpine

# Set the working directory inside the container to /app
WORKDIR /app

# Copy all files from the current directory on the host to the /app directory in the container
COPY . .

# Install only the production dependencies defined in package.json using yarn
RUN yarn install --production

# Define the command to run the application when the container starts
CMD [ "node", "src/index.js" ]

# Inform Docker that the container listens on port 3000 at runtime
EXPOSE 3000


# To build this dockerfile:

# sudo docker build -t ghosert/getting-started .

# To build image based on dockerfile, -t flag gives the image a name 'ghosert/getting-started'. you can refer to that image when running a container. The . at the end of the docker build command tells Docker that it should look for the Dockerfile in the current directory.


# To run this image 'ghosert/getting-started'

# sudo docker run -dp 127.0.0.1:3000:3000 ghosert/getting-started

# The -d flag (short for --detach) runs the container in the background. This means that Docker starts your container and returns you to the terminal prompt. You can verify that a container is running by running docker ps in the terminal.

# The -p flag (short for --publish) creates a port mapping between the host and the container. The -p flag takes a string value in the format of HOST:CONTAINER, where HOST is the address on the host, and CONTAINER is the port on the container. The command publishes the container's port 3000 to 127.0.0.1:3000 (localhost:3000) on the host. Without the port mapping, you wouldn't be able to access the application from the host.


# To list all the running containers, in this case showing 'ghosert/getting-started' is running
# sudo docker ps # sudo docker ps --all
# sudo docker stop <container-id>
# sudo docker rm <container-id> or use sudo docker rm -f <container-id> without stopping the container.

# After modifying something in the ./src/*.js files, you need to `docker stop/rm` the running containers and `docker build/run` again.

# Publish your docker image to docker hub.
# Re-tag your image with YOUR-USER-NAME in the tag before publishing to docker hub.
# sudo docker tag getting-started ghosert/getting-started
# sudo docker login -u ghosert
# sudo docker push ghosert/getting-started  # if ghosert/getting-started was built on amd64, and you need to pull from ARM, use `docker build --platform linux/arm/v7`
# sudo docker run -dp 127.0.0.1:3000:3000 ghosert/getting-started # this will look up local first, if not exist, go to docker hub to pull image and run.

# Playground with docker
# https://labs.play-with-docker.com, the below will pull the image we uploaded and run in playground.
# docker run -dp 0.0.0.0:3000:3000 ghosert/getting-started

# Create a volume and start the container to persist data generated by container.
# sudo docker volume create todo-db
# sudo docker volume ls
# sudo docker volume inspect todo-db
# sudo docker run -dp 127.0.0.1:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos ghosert/getting-started

# Make sure you are in getting-started folder
# sudo docker run -dp 127.0.0.1:3000:3000 \
#   -w /app --mount type=bind,src="$(pwd)",target=/app \
#   node:18-alpine \
#   sh -c "yarn install && yarn run dev"
#
# 'yarn run dev' make sure it's a hot deployment in dev env, if any changes in getting-started folder, will be reflected to the container and causes nodejs restart. You can use this command to check logs while modifying js src files in host.
#
# sudo docker logs -f <container-id>
#
# Update your js src files in host machine, and refresh your browser on localhost:3000, you will see logs above change and changes are reflected because of the bind mount.
# Stop the container and build a new image to consolidate your chages in the image:
#
# sudo docker build -t ghosert/getting-started .

# In general, each container should do one thing and do it well. The following are a few reasons to run the container separately:
# 1. There's a good chance you'd have to scale APIs and front-ends differently than databases.
# 2. Separate containers let you version and update versions in isolation.
# 3. While you may use a container for the database locally, you may want to use a managed service for the database in production. You don't want to ship your database engine with your app then.
# 4. Running multiple processes will require a process manager (the container only starts one process), which adds complexity to container startup/shutdown.


# Create the network first and then attach the MySQL container at startup.
#
# sudo docker network create todo-app
#
# sudo docker run -d \
#   --network todo-app --network-alias mysql \
#   -v todo-mysql-data:/var/lib/mysql \
#   -e MYSQL_ROOT_PASSWORD=secret \
#   -e MYSQL_DATABASE=todos \
#   mysql:8.0
#
# --network-alias flag above makes 'mysql' as hostname for the new container created. so app needs to connect to hostname 'mysql' only to talk to the database.
# -v todo-mysql-database:/var/lib/mysql will create a named volume "todo-mysql-database" and map to /var/lib/mysql in container.
# -v /var/lib/mysql will create a anomynous volume for you and map to /var/lib/mysql in container
# -v /var/lib/mysql:/var/lib/mysql means -v host_path:container_path, which equals to "--mount type=bind,src=/var/lib/mysql,target=/var/lib/mysql"
#
# 
# to confirm if database is running:
#
# sudo docker exec -it <mysql-container-id> mysql -u root -p
#
# Use this docker image tool to analyze netowrk
#
# sudo docker run -it --network todo-app nicolaka/netshoot
# dig mysql
#
# You will see something like this, which proves, 'mysql' is the hostname of mysql container, this was set in --network-alias mysql above
#
# ;; ANSWER SECTION:
# mysql.			600	IN	A	172.23.0.2

# Run your app with MySQL, host is set to 'mysql' network alias to connect mysql database
#
# docker run -dp 127.0.0.1:3000:3000 \
# -w /app -v "$(pwd):/app" \
# --network todo-app \
# -e MYSQL_HOST=mysql \
# -e MYSQL_USER=root \
# -e MYSQL_PASSWORD=secret \
# -e MYSQL_DB=todos \
# node:18-alpine \
# sh -c "yarn install && yarn run dev"


