<h2>Table of Contents</h2>

<h3><a href="#usage-1">Usage</a></h3>

<h3><a href="#syntax-1">Syntax</a></h3>

<h3><a href="#defs-and-blocks-1">Defs and Blocks</a></h3>

<h3><a href="#the-mako-runtime-environment-1">The Mako Runtime Environment</a></h3>

<h3><a href="#namespaces-1">Namespaces</a></h3>

<h3><a href="#inheritance-1">Inheritance</a></h3>

<h3><a href="#filtering-and-buffering-1">Filtering and Buffering</a></h3>

<h3><a href="#the-unicode-chapter-1">The Unicode Chapter</a></h3>

<h3><a href="#caching-1">Caching</a></h3>

<h2>Contents</h2>

<h2><a href="#usage">Usage</a></h2>

<p><strong>If you are using web framework like Pyramid, you can skip this 'Usage' section, otherwise, you'd like to generate you own html by Mako, check this section. See samples in ./test_mako.py</strong></p>

<h3>Basic Usage</h3>

<p><strong>1. template.render()</strong></p>

<p>```
from mako.template import Template</p>

<p>mytemplate = Template('hello world!')
print mytemplate.render()
```</p>

<p><strong>2. template.render(key='value')</strong></p>

<p>```
from mako.template import Template</p>

<p>mytemplate = Template('hello ${name}!')
print mytemplate.render(name='jack')
```</p>

<p><strong>3. Call render with your own context</strong></p>

<p>```
from mako.template import Template
from mako.runtime import Context
from StringIO import StringIO</p>

<p>mytemplate = Template('hello ${name}!')
buf = StringIO()
ctx = Context(buf, name='jack')
mytemplate.render_context(ctx)
print buf.getvalue()
```</p>

<h3>Using File-Based Templates</h3>

<p>```
from mako.template import Template</p>

<p>mytemplate = Template(filename='/docs/mytmpl.txt')
print mytemplate.render()
```</p>

<p>For improved performance, a Template which is loaded from a file can also cache the source code to its generated module on the filesystem as a regular Python module file (i.e. a .py file). </p>

<p>```
from mako.template import Template</p>

<p>mytemplate = Template(filename='docs/mytmpl.txt', module<em>directory='/tmp/mako</em>modules')
print mytemplate.render()
<code>`
The value of</code>module<em>directory<code>above should be a path in `sys.path` for example, you are running python file above in the</code>/tmp/mako</em>modules<code>, this path will be in `sys.path`, thus</code>/tmp/mako<em>modules<code>is a qualified</code>module</em>direcotry``.</p>

<p>When the above code is rendered, a file <code>/tmp/mako_modules/docs/mytmpl.txt.py</code> is created containing the source code for the module. The next time a Template with the same arguments is created, this module file will be automatically re-used.</p>

<h3>Using <code>TemplateLookup</code></h3>

<p><strong>1. TemplateLookup</strong></p>

<p>```
from mako.template import Template
from mako.lookup import TemplateLookup</p>

<p>mylookup = TemplateLookup(directories=['/docs'])
mytemplate = Template("""&lt;%include file="header.txt"/> hello world!""", lookup=mylookup)
print mytemplate.render()
<code>``
Above, we created a textual template which includes the file</code>header.txt<code>. In this way, it will search in the directory</code>/docs<code>for the file</code>header.txt`.</p>

<p><strong>2. TemplateLookup.get_template(templatename)</strong></p>

<p>```
from mako.template import Template
from mako.lookup import TemplateLookup</p>

<p>mylookup = TemplateLookup(directories=['/docs'], module<em>directory='/tmp/mako</em>modules')</p>

<p>def serve<em>template(templatename, <strong>kwargs):
    mytemplate = mylookup.get</em>template(templatename)
    print mytemplate.render(</strong>kwargs)
```</p>

<p>TemplateLookup will look for templates in the <code>/docs</code> directory, and will store generated module files in the <code>/tmp/mako_modules</code> directory. If given <code>/etc/beans/info.txt</code> as templatename, it would search for the file <code>/docs/etc/beans/info.txt</code> and create a module file <code>/tmp/mako_modules/etc/beans/info.txt.py</code></p>

<p><strong>3. Setting the Collection Size</strong></p>

<p>mylookup = TemplateLookup(directories=['/docs'],
                module<em>directory='/tmp/mako</em>modules', collection_size=500)</p>

<p>The above lookup will continue to load templates into memory until it reaches a count of around 500. At that point, it will clean out a certain percentage of templates using a least recently used scheme.</p>

<p>Skip the rest of the part, if you do need to refer to it, check out: http://docs.makotemplates.org/en/latest/usage.html#basic-usage</p>

<h2><a href="#syntax">Syntax</a></h2>

<h3>Expression Substitution</h3>

<p><code>
this  is x: ${x}
</code>
If x is not supplied, it evaluates to a special value <code>UNDEFINED</code>.</p>

<p>The contents within the ${} tag are evaluated by Python directly, so full expressions are OK:</p>

<p><code>
pythagorean theorem:  ${pow(x,2) + pow(y,2)}
</code></p>

<h3>Expression Escaping</h3>

<p>${"this is some text" | u}</p>

<p>The above expression applies URL escaping to the expression, and produces this+is+some+text. The u name indicates URL escaping, whereas h represents HTML escaping, x represents XML escaping, and trim applies a trim function.</p>

<h3>Control Structures</h3>

<p>conditionals(<code>if/else</code>), loops(<code>while/for</code>) as well as things like <code>try/except</code></p>

<p><code>
% if x==5:
    this is some output
% endif
</code>
the % can appear anywhere on the line as long as no text precedes it; indentation is not significant. The full range of Python "colon" expressions are allowed here, including if/elif/else, while, for, and even def, although Mako has a built-in tag for defs which is more full-featured.</p>

<p><code>
% for a in ['one', 'two', 'three', 'four', 'five']:
    % if a[0] == 't':
    its two or three
    % elif a[0] == 'f':
    four/five
    % else:
    one
    % endif
% endfor
</code></p>

<p>The % sign can also be "escaped", if you actually want to emit a percent sign as the first non whitespace character on a line, by escaping it as in %%:</p>

<p>```
%% some text</p>

<pre><code>%% some more text
</code></pre>

<p>```</p>

<h3>The Loop Context</h3>

<p>```</p>

<ul>
% for a in ("one", "two", "three"):
    <li>Item ${loop.index}: ${a}</li>
% endfor
</ul>

<p>```</p>

<h3>Comments</h3>

<p>Comments come in two varieties. The single line comment uses ## as the first non-space characters on a line:</p>

<p>```</p>

<h2>this is a comment.</h2>

<p>...text ...
```</p>

<p>A multiline version exists using &lt;%doc> ...text... </%doc>:</p>

<p><code>
&lt;%doc&gt;
    these are comments
    more comments
&lt;/%doc&gt;
</code></p>

<h3>Newline Filters</h3>

<p><code>
here is a line that goes onto \
another line.
</code></p>

<p>The above text evaluates to:</p>

<p><code>
here is a line that goes onto another line.
</code></p>

<h3>Python Blocks</h3>

<p>Any arbitrary block of python can be dropped in using the <code>&lt;% %&gt;</code> tags:</p>

<p><code>
this is a template
&lt;%
    x = db.get_resource('foo')
    y = [z.element for z in x if x.frobnizzle==5]
%&gt;
% for elem in y:
    element: ${elem}
% endfor
</code></p>

<h3>Module-level Blocks</h3>

<p>A variant on &lt;% %> is the module-level code block, denoted by &lt;%! %>.</p>

<p>```
&lt;%!
    import mylib
    import re</p>

<pre><code>def filter(text):
    return re.sub(r'^@', '', text)
</code></pre>

<p>%>
```</p>

<p>The code doesn't have access to the template's context and is only executed when the template is loaded into memory (which can be only once per application, or more, depending on the runtime environment). Use the &lt;%! %> tags to declare your template's imports, as well as any pure-Python functions you might want to declare:</p>

<h3>Tags</h3>

<p>The tag is closed either by a contained slash character, or an explicit closing tag:</p>

<p>```
&lt;%include file="foo.txt"/></p>

<p>&lt;%def name="foo" buffered="True">
    this is a def
</%def>
```</p>

<p>All tags have a set of attributes which are defined for each tag. Some of these attributes are required. Also, many attributes support evaluation, meaning you can embed an expression (using ${}) inside the attribute text:</p>

<p><code>
&lt;%include file="/foo/bar/${myfile}.txt"/&gt;
</code></p>

<h4><code>&lt;%page&gt;</code></h4>

<p>This tag defines general characteristics of the template, including caching arguments, and optional lists of arguments which the template expects when invoked.</p>

<p><code>
&lt;%page args="x, y, z='default'"/&gt;
</code></p>

<p>Or a page tag that defines caching characteristics:</p>

<p><code>
&lt;%page cached="True" cache_type="memory"/&gt;
</code></p>

<p>Currently, 0.7.4 only one <code>&lt;%page&gt;</code> tag gets used per template, the rest get ignored. See more below.</p>

<h4><code>&lt;%include&gt;</code></h4>

<p>```
&lt;%include file="header.html"/></p>

<pre><code>hello world
</code></pre>

<p>&lt;%include file="footer.html"/>
```</p>

<p>Include also accepts arguments which are available as &lt;%page> arguments in the receiving template:</p>

<p><code>
&lt;%include file="toolbar.html" args="current_section='members', username='ed'"/&gt;
</code></p>

<h4><code>&lt;%def&gt;</code></h4>

<p>The %def tag defines a Python function which contains a set of content, that can be called at some other point in the template. The basic idea is simple:</p>

<p>```
&lt;%def name="myfunc(x)">
    this is myfunc, x is ${x}
</%def></p>

<p>${myfunc(7)}
```</p>

<h4><code>&lt;%block&gt;</code></h4>

<p><code>%block</code> is a tag that is close to a %def, except executes itself immediately in its base-most scope, and can also be anonymous (i.e. with no name):</p>

<p><code>
&lt;%block filter="h"&gt;
    some &lt;html&gt; stuff.
&lt;/%block&gt;
</code></p>

<p>jiawzhang: Not sure what is the <code>&lt;%block&gt;</code> for so far, see below for details.</p>

<h4><code>&lt;%namespace&gt;</code></h4>

<p><code>%namespace</code> is Mako's equivalent of Python's import statement. It allows access to all the rendering functions and metadata of other template files, plain Python modules, as well as locally defined "packages" of functions.</p>

<p><code>
&lt;%namespace file="functions.html" import="*"/&gt;
</code></p>

<p>See below for details.</p>

<h4><code>&lt;%inherit&gt;</code></h4>

<p>Inherit allows templates to arrange themselves in inheritance chains.</p>

<p><code>
&lt;%inherit file="base.html"/&gt;
</code></p>

<h4><code>&lt;%nsname:defname&gt;</code></h4>

<p>user-defined "tag"</p>

<p><code>
&lt;%mynamespace:somedef param="some value"&gt;
    this is the body
&lt;/%mynamespace:somedef&gt;
</code></p>

<h4><code>&lt;%call&gt;</code></h4>

<p>user-defined "tag" and is roughly equivalent to the <code>&lt;%nsname:defname&gt;</code> syntax described above.</p>

<h4><code>&lt;%doc&gt;</code></h4>

<p>For multiline comments, see above.</p>

<h4><code>&lt;%text&gt;</code></h4>

<p>This tag suspends the Mako lexer's normal parsing of Mako template directives, and returns its entire body contents as plain text. It is used pretty much to write documentation about Mako:</p>

<p><code>
&lt;%text filter="h"&gt;
    heres some fake mako ${syntax}
    &lt;%def name="x()"&gt;${x}&lt;/%def&gt;
&lt;/%text&gt;
</code></p>

<h4>Returning Early from a Template</h4>

<p>Sometimes you want to stop processing a template or &lt;%def> method in the middle and just use the text you've accumulated so far. You can use a return statement inside a Python block to do that.</p>

<p><code>
% if not len(records):
    No records found.
    &lt;% return %&gt;
% endif
</code></p>

<p>Or perhaps:</p>

<p><code>
&lt;%
    if not len(records):
        return
%&gt;
</code></p>

<h2><a href="#defs-and-blocks">Defs and Blocks</a></h2>

<p>Whereas &lt;%def> provides a construct that is very much like a named Python def, the &lt;%block> is more layout oriented.</p>

<h3>Using Defs</h3>

<p><code>
&lt;%def name="hello()"&gt;
    hello world
&lt;/%def&gt;
</code>
To invoke the <code>&lt;%def&gt;</code></p>

<p><code>
the def: ${hello()}
</code></p>

<p><strong>top level def</strong>(the <code>&lt;%def&gt;</code> is not nested inside of another <code>&lt;%def&gt;</code>) can be accessed anywhere in the template, including above where it was defined.</p>

<p>All defs have access to the current contextual namespace in exactly the same way their containing template does.</p>

<p>```
Hello there ${username}, how are ya.  Lets see what your account says:</p>

<p>${account()}</p>

<p>&lt;%def name="account()">
    Account for ${username}:<br/></p>

<pre><code>% for row in accountdata:
    Value: ${row}&lt;br/&gt;
% endfor
</code></pre>

<p></%def>
```</p>

<p>The <code>username</code> and <code>accountdata</code> variables are present within the main template body as well as the body of the account() def.</p>

<p>Since defs are just Python functions, you can define and pass arguments to them as well:</p>

<p>${account(accountname='john')}</p>

<p>&lt;%def name="account(accountname, type='regular')">
    account name: ${accountname}, type: ${type}
</%def></p>

<h4>Calling Defs from Other Files</h4>

<p>Calling a &lt;%def> from another template is something like using an &lt;%include> – except you are calling a specific function within the template, not the whole template.</p>

<p>To import another template, use the &lt;%namespace> tag:</p>

<p><code>
&lt;%namespace name="mystuff" file="mystuff.html"/&gt;
</code></p>

<p>The above tag adds a local variable mystuff to the current scope.</p>

<p>Then, just call the defs off of mystuff:</p>

<p><code>
${mystuff.somedef(x=5,y=7)}
</code></p>

<p>The &lt;%namespace> tag also supports some of the other semantics of Python's import statement, including pulling names into the local variable space, or using * to represent all names, using the import attribute:</p>

<p>&lt;%namespace file="mystuff.html" import="foo, bar"/></p>

<h4>Calling Defs Programmatically</h4>

<p>You can call defs programmatically from any Template object using the get_def() method, which returns a DefTemplate object.</p>

<p>```
from mako.template import Template</p>

<p>template = Template("""
    &lt;%def name="hi(name)">
        hi ${name}!
    </%def></p>

<pre><code>&lt;%def name="bye(name)"&gt;
    bye ${name}!
&lt;/%def&gt;
</code></pre>

<p>""")</p>

<p>print template.get<em>def("hi").render(name="ed")
print template.get</em>def("bye").render(name="ed")
```</p>

<h4>Defs within Defs</h4>

<p>&lt;%def> is basically def keyword in python to define function, so that nested &lt;%def> is allowed.</p>

<p>```
&lt;%def name="mydef()">
    &lt;%def name="subdef()">
        a sub def
    </%def></p>

<pre><code>i'm the def, and the subcomponent is ${subdef()}
</code></pre>

<p></%def>
```</p>

<p>Just like Python, names that exist outside the inner &lt;%def> exist inside it as well:</p>

<p>```
&lt;%
    x = 12
%>
&lt;%def name="outer()">
    &lt;%
        y = 15
    %>
    &lt;%def name="inner()">
        inner, x is ${x}, y is ${y}
    </%def></p>

<pre><code>outer, x is ${x}, y is ${y}
</code></pre>

<p></%def>
```</p>

<h4>Calling a Def with Embedded Content and/or Other Defs</h4>

<p>```
&lt;%def name="buildtable()">
    <table>
        <tr><td>
            ${caller.body()}
        </td></tr>
    </table>
</%def></p>

<p>&lt;%self:buildtable>
    I am the table body.
</%self:buildtable>
```</p>

<p>This produces the output (whitespace formatted):</p>

<p>```</p>

<table>
    <tr><td>
        I am the table body.
    </td></tr>
</table>

<p>```</p>

<p>Using the older %call syntax looks like:</p>

<p>```
&lt;%def name="buildtable()">
    <table>
        <tr><td>
            ${caller.body()}
        </td></tr>
    </table>
</%def></p>

<p>&lt;%call expr="buildtable()">
    I am the table body.
</%call>
```</p>

<p>The body() can be executed multiple times or not at all. This means you can use def-call-with-content to build iterators, conditionals, etc:</p>

<p>```
&lt;%def name="lister(count)">
    % for x in range(count):
        ${caller.body()}
    % endfor
</%def></p>

<p>&lt;%self:lister count="${3}">
    hi
</%self:lister>
```</p>

<p>Produces:</p>

<p><code>
hi
hi
hi
</code></p>

<p>Notice above we pass 3 as a Python expression, so that it remains as an integer.</p>

<p>A custom "conditional" tag:</p>

<p>```
&lt;%def name="conditional(expression)">
    % if expression:
        ${caller.body()}
    % endif
</%def></p>

<p>&lt;%self:conditional expression="${4==4}">
    i'm the result
</%self:conditional>
```</p>

<p>Produces:</p>

<p><code>
i'm the result
</code></p>

<p>The body() function also can handle arguments, which will augment the local namespace of the body callable. The caller must define the arguments which it expects to receive from its target def using the <code>args</code> attribute(<code>args="col"</code> below), which is a comma-separated list of argument names, we defined "col" below in caller's body as argument and then pass the value from customize tag <code>layoutdata</code> by <code>${caller.body(col=col)}</code>:</p>

<p>```
&lt;%def name="layoutdata(somedata)">
    <table>
    % for item in somedata:
        <tr>
        % for col in item:
            <td>${caller.body(col=col)}</td>
        % endfor
        </tr>
    % endfor
    </table>
</%def></p>

<p>&lt;%self:layoutdata somedata="${[[1,2,3],[4,5,6],[7,8,9]]}" args="col">\
Body data: ${col}\
</%self:layoutdata>
```</p>

<p>Produces:</p>

<p>```</p>

<table>
    <tr>
        <td>Body data: 1</td>
        <td>Body data: 2</td>
        <td>Body data: 3</td>
    </tr>
    <tr>
        <td>Body data: 4</td>
        <td>Body data: 5</td>
        <td>Body data: 6</td>
    </tr>
    <tr>
        <td>Body data: 7</td>
        <td>Body data: 8</td>
        <td>Body data: 9</td>
    </tr>
</table>

<p>```</p>

<p>You don't have to stick to calling just the body() function. The caller can define any number of callables, allowing the &lt;%call> tag to produce whole layouts:</p>

<p>```
&lt;%def name="layout()">
    ## a layout def
    <div class="mainlayout">
        <div class="header">
            ${caller.header()}
        </div></p>

<pre><code>    &lt;div class="sidebar"&gt;
        ${caller.sidebar()}
    &lt;/div&gt;

    &lt;div class="content"&gt;
        ${caller.body()}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p></%def></p>

<p>## calls the layout def
&lt;%self:layout>
    &lt;%def name="header()">
        I am the header
    </%def>
    &lt;%def name="sidebar()">
        <ul>
            <li>sidebar 1</li>
            <li>sidebar 2</li>
        </ul>
    </%def></p>

<pre><code>    this is the body
</code></pre>

<p></%self:layout>
```</p>

<p>The above layout would produce:</p>

<p>```</p>

<div class="mainlayout">
    <div class="header">
    I am the header
    </div>

    <div class="sidebar">
    <ul>
        <li>sidebar 1</li>
        <li>sidebar 2</li>
    </ul>
    </div>

    <div class="content">
    this is the body
    </div>
</div>

<p>```</p>

<p>Basically anything you'd do with a "custom tag" or tag library in some other system, Mako provides via &lt;%def> tags and plain Python callables which are invoked via &lt;%namespacename:defname> or &lt;%call>.</p>

<h3>Using Blocks</h3>

<p>The <code>&lt;%block&gt;</code> tag compared with <code>&lt;%def&gt;</code> is more closely tailored towards layout.</p>

<p><code>
&lt;html&gt;
    &lt;body&gt;
        &lt;%block&gt;
            this is a block.
        &lt;/%block&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>The block renders its content in the place that it's defined. Since there is no block <code>name</code> above, it's <strong>anonymous block</strong> which will produce:</p>

<p><code>
&lt;html&gt;
    &lt;body&gt;
            this is a block.
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>So in fact the above block has absolutely no effect. Its usefulness comes when we start using modifiers. Such as, we can apply a filter to our block:</p>

<p><code>
&lt;html&gt;
    &lt;body&gt;
        &lt;%block filter="h"&gt;
            &lt;html&gt;this is some escaped html.&lt;/html&gt;
        &lt;/%block&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p><code>&lt;html&gt;this is some escaped html.&lt;/html&gt;</code> will be converted to <code>&amp;lt;html&amp;gt;this is some escaped html.&amp;lt;/html&amp;gt;</code></p>

<p>or perhaps a caching directive:</p>

<p><code>
&lt;html&gt;
    &lt;body&gt;
        &lt;%block cached="True" cache_timeout="60"&gt;
            This content will be cached for 60 seconds.
        &lt;/%block&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>Blocks also work in iterations, conditionals, just like defs:</p>

<p><code>
% if some_condition:
    &lt;%block&gt;condition is met&lt;/%block&gt;
% endif
</code></p>

<p>Anonymous blocks are defined as closures in the local rendering body, so have access to local variable scope:</p>

<p><code>
% for i in range(1, 4):
    &lt;%block&gt;i is ${i}&lt;/%block&gt;
% endfor
</code></p>

<h4>Using Named Blocks</h4>

<p>Possibly the more important area where blocks are useful is when we do actually give them names. In sharp contrast to the &lt;%def> tag, the name given to a block is global for the entire template regardless of how deeply it's nested:</p>

<p><code>
&lt;html&gt;
&lt;%block name="header"&gt;
    &lt;head&gt;
        &lt;title&gt;
            &lt;%block name="title"&gt;Title&lt;/%block&gt;
        &lt;/title&gt;
    &lt;/head&gt;
&lt;/%block&gt;
&lt;body&gt;
    ${next.body()}
&lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>The above example has two named blocks "header" and "title", both of which can be referred to by an inheriting template. A detailed walkthrough of this usage can be found at Inheritance.</p>

<p>Note above that named blocks don't have any argument declaration the way defs do.</p>

<p>```</p>

<div name="page">
    <%block name="pagecontrol">
        <a href="">previous page</a> |
        <a href="">next page</a>
    </%block>

    <table>
        ## some content
    </table>

    ${pagecontrol()}
</div>

<p>```</p>

<p>The content referenced by pagecontrol above will be rendered both above and below the <table> tags.</p>

<p>&lt;%block> name should be unique to other &lt;%block> and top level &lt;%def>
A named &lt;%block> cannot be defined within a &lt;%def>, or inside the body of a "call", i.e. &lt;%call> or &lt;%namespacename:defname> tag. Anonymous blocks can, however.</p>

<h4>Using Page Arguments in Named Blocks</h4>

<p>Using arguments with the &lt;%page> tag is described in the section <a href="http://docs.makotemplates.org/en/latest/namespaces.html#namespaces-body">The body() Method</a>, to allow a named block to share the same arguments passed to the page, the <code>args</code> attribute can be used:</p>

<p>```
&lt;%page args="post"/></p>

<p><a name="${post.title}" /></p>

<p><span class="post_prose">
    &lt;%block name="post_prose" args="post">
        ${post.content}
    </%block>
</span>
```</p>

<p>Where above, if the template is called via a directive like &lt;%include file="post.mako" args="post=post" />, the post variable is available both in the main body as well as the post_prose block.</p>

<p>Similarly, the **pageargs variable is present, in named blocks only, for those arguments not explicit in the &lt;%page> tag:</p>

<p><code>
&lt;%block name="post_prose"&gt;
    ${pageargs['post'].content}
&lt;/%block&gt;
</code></p>

<p>The args attribute is only allowed with named blocks. With anonymous blocks, the Python function is always rendered in the same scope as the call itself, so anything available directly outside the anonymous block is available inside as well.</p>

<h2><a href="#the-mako-runtime-environment">The Mako Runtime Environment</a></h2>

<h3>Context</h3>

<h3>The Buffer</h3>

<p>Occasionally, you want to programmatically send content to the output stream, such as within a <code>&lt;% %&gt;</code> block.
<code>
&lt;%
    context.write("some programmatic text")
%&gt;
</code></p>

<h3>Context Variables</h3>

<p>If you think UNDEFINE makes it hard to find what name is missing in Context, secify the option "strict_undefined=True" to the Template or TemplateLookup. This will cause any non-present variables to raise an immediate <code>NameError</code>, <code>UNDEFINED</code> is not used.</p>

<p><code>
% if someval is UNDEFINED:
    someval is: no value
% else:
    someval is: ${someval}
% endif
</code></p>

<p>what if I want to set values that are global to everyone within a template request?</p>

<p>Running the template looks like:</p>

<p><code>
output = template.render(attributes={})
</code></p>

<p>Within a template, just reference the dictionary:</p>

<p><code>
&lt;%
    attributes['foo'] = 'bar'
%&gt;
'foo' attribute is: ${attributes['foo']}
</code></p>

<h3>Context Methods and Accessors</h3>

<ul>
<li>context[key] / context.get(key, default=None)</li>
<li>context.keys - all the names defined within this context.</li>
<li>context.kwargs - this returns a copy of the context's dictionary of variables. This is useful when you want to propagate the variables in the current context to a function as keyword arguments, i.e.:
<code>
${next.body(**context.kwargs)}
</code></li>
<li>context.write(text) - write some text to the current output stream.</li>
<li>context.lookup - returns the <code>TemplateLookup</code> instance that is used for all file-lookups within the current execution.</li>
</ul>

<h3>The Loop Context</h3>

<p>Within <code>% for</code> blocks, the reserved name <code>loop</code> is available.</p>

<p>```</p>

<ul>
% for a in ("one", "two", "three"):
    <li>Item ${loop.index}: ${a}</li>
% endfor
</ul>

<p>```</p>

<h4>Iterations</h4>

<ul>
<li><code>loop.index</code> - 0-indexed iteration count</li>
<li><code>loop.even</code> / <code>loop.odd</code> bools - loop parity</li>
<li><code>loop.first</code> bool - whether the loop is on its first iteration</li>
</ul>

<p>If your iterable provides a <code>__len__</code> method, the below two attributes are available:</p>

<ul>
<li>loop.reverse_index - a count of iterations remaining</li>
<li>loop.last - a bool indicating whether the loop is on its last iteration
Accessing them without <code>__len__</code> will raise a <code>TypeError</code></li>
</ul>

<h4>Cycling</h4>

<p>Cycling is available regardless of whether the iterable you're using provides a <strong>len</strong> method.</p>

<p>```</p>

<ul>
% for i, item in enumerate(('spam', 'ham', 'eggs')):
  <li class="${'odd' if i % 2 else 'even'}">${item}</li>
% endfor
</ul>

<p>```</p>

<p>With loop.cycle, you get the same results with cleaner code and less prep work:</p>

<p>```</p>

<ul>
% for item in ('spam', 'ham', 'eggs'):
  <li class="${loop.cycle('even', 'odd')}">${item}</li>
% endfor
</ul>

<p>```</p>

<p>Both approaches produce output like the following:</p>

<p>```</p>

<ul>
  <li class="even">spam</li>
  <li class="odd">ham</li>
  <li class="even">eggs</li>
</ul>

<p>```</p>

<h4>Parent Loops</h4>

<p>Access the parent loop context through <code>loop.parent</code> or <code>loop.parent.parent....</code></p>

<p>```</p>

<table>
% for consonant in 'pbj':
  <tr>
  % for vowel in 'iou':
    <td class="${'black' if (loop.parent.even == loop.even) else 'red'}">
      ${consonant + vowel}t
    </td>
  % endfor
  </tr>
% endfor
</table>

<p>```</p>

<h4>All the Built-in Names</h4>

<p>See more details <a href="http://docs.makotemplates.org/en/latest/runtime.html">here</a></p>

<h4>Reserved Names</h4>

<p>See more details <a href="http://docs.makotemplates.org/en/latest/runtime.html">here</a></p>

<h4>API Reference</h4>

<p>See more details <a href="http://docs.makotemplates.org/en/latest/runtime.html">here</a></p>

<h2><a href="#namespaces">Namespaces</a></h2>

<p>If the file components.html defines these two defs:</p>

<p>```
 ## components.html
&lt;%def name="comp1()">
    this is comp1
</%def></p>

<p>&lt;%def name="comp2(x)">
    this is comp2, x is ${x}
</%def>
```</p>

<p>you can make another file, for example index.html, that pulls those two defs into a namespace called comp:</p>

<p>```
 ## index.html
&lt;%namespace name="comp" file="components.html"/></p>

<p>Here's comp1:  ${comp.comp1()}
Here's comp2:  ${comp.comp2(x=5)}
```</p>

<p>Use the <code>import</code> attribute.</p>

<p>```
&lt;%namespace file="components.html" import="comp1, comp2"/></p>

<p>Heres comp1:  ${comp1()}
Heres comp2:  ${comp2(x=5)}
```</p>

<p>import also supports the "*" operator:</p>

<p>```
&lt;%namespace file="components.html" import="*"/></p>

<p>Heres comp1:  ${comp1()}
Heres comp2:  ${comp2(x=5)}
```</p>

<p>The file argument allows expressions – if looking for context variables, the context must be named explicitly:</p>

<p><code>
&lt;%namespace name="dyn" file="${context['namespace_name']}"/&gt;
</code></p>

<p>instead of being named implicitly like:</p>

<p><code>
&lt;%namespace name="dyn" file="${namespace_name}"/&gt;
</code></p>

<h3>Ways to Call Namespaces</h3>

<p><strong>1. expressions like any other function:</strong></p>

<p>${mynamespace.somefunction('some arg1', 'some arg2', arg3='some arg3', arg4='some arg4')}</p>

<p><strong>2. "custom" Mako tag, with the function arguments passed in using named attributes:</strong></p>

<p>&lt;%mynamespace:somefunction arg1="some arg1" arg2="some arg2" arg3="some arg3" arg4="some arg4"/></p>

<p><strong>3. To embed Python expressions as arguments, use the embedded expression format:</strong></p>

<p>&lt;%mynamespace:somefunction arg1="${someobject.format()}" arg2="${somedef(5, 12)}"/></p>

<p><strong>4. The "custom tag" format is intended mainly for namespace functions which recognize body content(like <code>&lt;%self:buildtable&gt;</code> above, there should be a <code>caller.body()</code> in namespace function):</strong></p>

<p>&lt;%mynamespace:somefunction arg1="some argument" args="x, y">
    Some record: ${x}, ${y}
</%mynamespace:somefunction></p>

<h3>Namespaces from Regular Python Modules</h3>

<p>Make sure the callables need to take at least one argument, <code>context</code>, an instance of <code>Context</code>. A module file <code>some/module.py</code> might contain the callable:</p>

<p><code>
def my_tag(context):
    context.write("hello world")
    return ''
</code></p>

<p>A template can use this module via:</p>

<p>```
&lt;%namespace name="hw" module="some.module"/></p>

<p>${hw.my_tag()}
```</p>

<p>The return value of <code>def</code> coming with <code>context.write()</code> is rendered after the <code>def</code> completes. So that "my_tag(context)" above should return '' instead of <code>None</code> if nothing should be rendered from "return"</p>

<p>To make sure your def is to be called in an "embedded content" context like <code>&lt;%self:buildtable&gt;</code> above, Add "@supports_caller" on your def and get body by conext['caller'].body():</p>

<p>```
from mako.runtime import supports_caller</p>

<p>@supports<em>caller
def my</em>tag(context):
    context.write("<div>")
    context['caller'].body()
    context.write("</div>")
    return ''
```</p>

<p>Capturing of output is available as well like this:</p>

<p>```
from mako.runtime import supports_caller, capture</p>

<p>@supports<em>caller
def my</em>tag(context):
    return "<div>%s</div>" % \
            capture(context, context['caller'].body, x="foo", y="bar")
```</p>

<h3>Declaring Defs in Namespaces</h3>

<p>```
 ## define a namespace
&lt;%namespace name="stuff">
    &lt;%def name="comp1()">
        comp1
    </%def>
</%namespace></p>

<p>## then call it
${stuff.comp1()}
```</p>

<h3>The <code>body()</code> Method</h3>

<p><code>
 ## base.html
&lt;%page args="x, y, someval=8, scope='foo', **kwargs"/&gt;
</code></p>

<p>So above, the body might be called as:</p>

<p>```
 ## somefile.html
&lt;%inherit file="base.html"/></p>

<p>${self.body(5, y=10, someval=15, delta=7)}
```</p>

<p>The Context object also supplies a kwargs accessor, for cases when you'd like to pass along whatever is in the context to a body() callable:</p>

<p>${next.body(**context.kwargs)}</p>

<h3>Built-in Namespaces</h3>

<p><code>local</code></p>

<p>The local namespace is basically the namespace for the currently executing template. This means that all of the top level defs defined in your template, as well as your template's body() function, are also available off of the local namespace.</p>

<p>The local namespace is also where properties like uri, filename, and module and the get_namespace method can be particularly useful.</p>

<p><code>self</code></p>

<p>The self namespace, in the case of a template that does not use inheritance, is synonymous with local. If inheritance is used, then self references the topmost template in the inheritance chain. The <code>self</code> above represents the <code>somefile.html</code></p>

<h3>Inheritable Namespaces</h3>

<p>The &lt;%namespace> tag includes an optional attribute inheritable="True", which will cause the namespace to be attached to the self namespace.</p>

<p>```
 ## base.html
&lt;%namespace name="foo" file="foo.html" inheritable="True"/></p>

<p>${next.body()}</p>

<p>## somefile.html
&lt;%inherit file="base.html"/></p>

<p>${self.foo.bar()}
```</p>

<h3>Namespace API Usage Example - Static Dependencies</h3>

<h4>Version One - Use Namespace.attr</h4>

<p>The Namespace.attr attribute allows us to locate any variables declared in the &lt;%! %> of a template.</p>

<p>```
 ## base.mako
 ## base-most template, renders layout etc.
<html>
<head>
 ## traverse through all namespaces present,
 ## look for an attribute named 'includes'
% for ns in context.namespaces.values():
    % for incl in getattr(ns.attr, 'includes', []):
        ${incl}
    % endfor
% endfor
</head>
<body>
${next.body()}
</body
</html></p>

<p>## library.mako
 ## library functions.
&lt;%!
    includes = [
        '<link rel="stylesheet" type="text/css" href="mystyle.css"/>',
        '<script type="text/javascript" src="functions.js"></script>'
    ]
%></p>

<p>&lt;%def name="mytag()">
    <form>
        ${caller.body()}
    </form>
</%def></p>

<p>## index.mako
 ## calling template.
&lt;%inherit file="base.mako"/>
&lt;%namespace name="foo" file="library.mako"/></p>

<p>&lt;%foo:mytag>
    a form
</%foo:mytag>
```</p>

<h4>Version Two - Use a specific named def</h4>

<p>In this version, we put the includes into a &lt;%def> that follows a naming convention.</p>

<p>```
 ## base.mako
 ## base-most template, renders layout etc.
<html>
<head>
 ## traverse through all namespaces present,
 ## look for a %def named 'includes'
% for ns in context.namespaces.values():
    % if hasattr(ns, 'includes'):
        ${ns.includes()}
    % endif
% endfor
</head>
<body>
${next.body()}
</body
</html></p>

<p>## library.mako
 ## library functions.</p>

<p>&lt;%def name="includes()">
    <link rel="stylesheet" type="text/css" href="mystyle.css"/>
    <script type="text/javascript" src="functions.js"></script>
</%def></p>

<p>&lt;%def name="mytag()">
    <form>
        ${caller.body()}
    </form>
</%def></p>

<p>## index.mako
 ## calling template.
&lt;%inherit file="base.mako"/>
&lt;%namespace name="foo" file="library.mako"/></p>

<p>&lt;%foo:mytag>
    a form
</%foo:mytag>
```</p>

<h3>API Reference</h3>

<p>See more details <a href="http://docs.makotemplates.org/en/latest/namespaces.html#the-body-method">here</a></p>

<h2><a href="#inheritance">Inheritance</a></h2>

<p>In practice, it looks like this. Here's a hypothetical inheriting template, index.html:</p>

<p>```
 ## index.html
&lt;%inherit file="base.html"/></p>

<p>&lt;%block name="header">
    this is some header content
</%block></p>

<p>this is the body content.
```</p>

<p>And base.html, the inherited template:</p>

<p>```
 ## base.html
<html>
    <body>
        <div class="header">
            &lt;%block name="header"/>
        </div></p>

<pre><code>    ${self.body()}

    &lt;div class="footer"&gt;
        &lt;%block name="footer"&gt;
            this is the footer
        &lt;/%block&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>base.html then renders the top part of an HTML document, then invokes the &lt;%block name="header"> block. It invokes the underlying header() function off of a built-in namespace called self (this namespace was first introduced in the Namespaces chapter in self). Since index.html is the topmost template and also defines a block called header, it's this header block that ultimately gets executed – instead of the one that's present in base.html.</p>

<p>base.html executes self.body(). The body() function on all template-based namespaces refers to the main body of the template, therefore the main body of index.html is rendered.</p>

<p>When &lt;%block name="header"> is encountered in index.html during the self.body() call, a conditional is checked – does the current inherited template, i.e. base.html, also define this block? If yes, the &lt;%block> is not executed here – the inheritance mechanism knows that the parent template is responsible for rendering this block (and in fact it already has). In other words a block only renders in its basemost scope. Means &lt;%block name="header"> is defined in base.html, so that self.body() will not present &lt;%block name="header"> in index.html.</p>

<p>The footer block is only defined in base.html, so being the topmost definition of footer, it's the one that executes. If index.html also specified footer, then its version would override that of the base.</p>

<p>The above, producing:</p>

<p>```
<html>
    <body>
        <div class="header">
            this is some header content
        </div></p>

<pre><code>    this is the body content.

    &lt;div class="footer"&gt;
        this is the footer
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h3>Nesting Blocks</h3>

<p>```
 ## base.html
<html>
    <body>
        <div class="header">
            &lt;%block name="header">
                <h2>
                    &lt;%block name="title"/>
                </h2>
            </%block>
        </div></p>

<pre><code>    ${self.body()}

    &lt;div class="footer"&gt;
        &lt;%block name="footer"&gt;
            this is the footer
        &lt;/%block&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>The inheriting template can name either or both of header and title, separately or nested themselves:</p>

<p>```
 ## index.html
&lt;%inherit file="base.html"/></p>

<p>&lt;%block name="header">
    this is some header content
    ${parent.header()}
</%block></p>

<p>&lt;%block name="title">
    this is the title
</%block></p>

<p>this is the body content.
```</p>

<p>Note when we overrode header, we added an extra call ${parent.header()} in order to invoke the parent's header block in addition to our own.</p>

<h3>Rendering a Named Block Multiple Times</h3>

<p>Recall from the section Using Blocks that a named block is just like a &lt;%def>, with some different usage rules.</p>

<p><code>
 ## base.html
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;${self.title()}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;%block name="header"&gt;
        &lt;h2&gt;&lt;%block name="title"/&gt;&lt;/h2&gt;
    &lt;/%block&gt;
    ${self.body()}
    &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>Where above an inheriting template can define <code>&lt;%block name="title"&gt;</code> just once, and it will be used in the base template both in the <code>&lt;title&gt;</code> section as well as the <code>&lt;h2&gt;</code>.</p>

<h3>But what about Defs?</h3>

<p><code>&lt;%block&gt;</code> is more streamlined compared with <code>&lt;%def&gt;</code>, we should prefer <code>&lt;%block&gt;</code> to <code>&lt;%def&gt;</code>, if you do want to see <code>&lt;%def&gt;</code> sample, here is it:</p>

<p>```
 ## index.html
&lt;%inherit file="base.html"/></p>

<p>&lt;%def name="header()">
    this is some header content
</%def></p>

<p>this is the body content.
```</p>

<p>And base.html, the inherited template:</p>

<p>```
 ## base.html
<html>
    <body>
        <div class="header">
            ${self.header()}
        </div></p>

<pre><code>    ${self.body()}

    &lt;div class="footer"&gt;
        ${self.footer()}
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html></p>

<p>&lt;%def name="header()"/>
&lt;%def name="footer()">
    this is the footer
</%def>
```</p>

<p>Above, we illustrate that defs differ from blocks in that their definition and invocation are defined in two separate places, instead of at once(blocks is at once). You can almost do exactly what a block does if you put the two together:</p>

<p>```</p>

<div class="header">
    <%def name="header()"></%def>${self.header()}
</div>

<p>```</p>

<p>See more details on <a href="http://docs.makotemplates.org/en/latest/inheritance.html#rendering-a-named-block-multiple-times"><code>But what about Defs?</code></a> ..., since in most case, Blocks could replace Defs, we are not going to care too much on the rest of this section.</p>

<h3>Using the <code>next</code> Namespace to Produce Content Wrapping</h3>

<p>```
 ## base.html
<html>
    <body>
        <div class="header">
            &lt;%block name="header"/>
        </div></p>

<pre><code>    ${next.body()}

    &lt;div class="footer"&gt;
        &lt;%block name="footer"&gt;
            this is the footer
        &lt;/%block&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>Lets also add an intermediate template called layout.html, which inherits from base.html:</p>

<p>```
 ## layout.html
&lt;%inherit file="base.html"/></p>

<ul>
    <%block name="toolbar">
        <li>selection 1</li>
        <li>selection 2</li>
        <li>selection 3</li>
    </%block>
</ul>

<div class="mainlayout">
    ${next.body()}
</div>

<p>```</p>

<p>And finally change index.html to inherit from layout.html instead:</p>

<p>```
 ## index.html
&lt;%inherit file="layout.html"/></p>

<p>&lt;%def name="header()">
    this is some header content
</%def></p>

<p>this is the body content.
```</p>

<p>In this setup, each call to next.body() will render the body of the next template in the inheritance chain (which can be written as base.html -> layout.html -> index.html). Control is still first passed to the bottommost template base.html, and self still references the topmost definition of any particular def.</p>

<p>The output we get would be:</p>

<p>```
<html>
    <body>
        <div class="header">
            this is some header content
        </div></p>

<pre><code>    &lt;ul&gt;
        &lt;li&gt;selection 1&lt;/li&gt;
        &lt;li&gt;selection 2&lt;/li&gt;
        &lt;li&gt;selection 3&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class="mainlayout"&gt;
    this is the body content.
    &lt;/div&gt;

    &lt;div class="footer"&gt;
        this is the footer
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>Without the <code>next</code> namespace, only the main body of index.html could be used; there would be no way to call layout.html's body content.</p>

<h3>Using the parent Namespace to Augment Defs</h3>

<p>The opposite of next called parent. Let's modify <code>index.html</code> above to augment the list of selections provided by the <code>toolbar</code> function in <code>layout.html</code>:</p>

<p>```
 ## index.html
&lt;%inherit file="layout.html"/></p>

<p>&lt;%block name="header">
    this is some header content
</%block></p>

<p>&lt;%block name="toolbar">
    ## call the parent's toolbar first
    ${parent.toolbar()}
    <li>selection 4</li>
    <li>selection 5</li>
</%block></p>

<p>this is the body content.
```</p>

<p>Above, we implemented a toolbar() function, which is meant to override the definition of toolbar within the inherited template layout.html. However, since we want the content from that of layout.html as well, we call it via the parent namespace whenever we want it's content, in this case before we add our own selections. So the output for the whole thing is now:</p>

<p>```
<html>
    <body>
        <div class="header">
            this is some header content
        </div></p>

<pre><code>    &lt;ul&gt;
        &lt;li&gt;selection 1&lt;/li&gt;
        &lt;li&gt;selection 2&lt;/li&gt;
        &lt;li&gt;selection 3&lt;/li&gt;
        &lt;li&gt;selection 4&lt;/li&gt;
        &lt;li&gt;selection 5&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class="mainlayout"&gt;
    this is the body content.
    &lt;/div&gt;

    &lt;div class="footer"&gt;
        this is the footer
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>and you're now a template inheritance ninja!</p>

<h3>Inheritable Attributes</h3>

<p>The <code>attr</code> accessor of the <code>Namespace</code> object allows access to module level variables declared in a template. By accessing <code>self.attr</code>, you can access regular attributes from the inheritance chain as declared in <code>&lt;%! %&gt;</code> sections. Such as:</p>

<p>```
&lt;%!
    class_ = "grey"
%></p>

<div class="${self.attr.class_}">
    ${self.body()}
</div>

<p>```</p>

<p>If an inheriting template overrides class_ to be "white", as in:</p>

<p>```
&lt;%!
    class_ = "white"
%>
&lt;%inherit file="parent.html"/></p>

<p>This is the body
```</p>

<p>you'll get output like:</p>

<p>```</p>

<div class="white">
    This is the body
</div>

<p>```</p>

<h2><a href="#filtering-and-buffering">Filtering and Buffering</a></h2>

<h3>Expression Filtering</h3>

<p>u, h, x, trim, entity, unicode, decode.<some encoding>(decode.utf8), n(disable all default filtering, only local expression tag will be applied, see below)</p>

<p><code>
${" &lt;tag&gt;some value&lt;/tag&gt; " | h,trim}
</code></p>

<p>produces:</p>

<p><code>
&amp;lt;tag&amp;gt;some value&amp;lt;/tag&amp;gt;
</code></p>

<p>Make your own filters:</p>

<p>```
&lt;%!
    def myescape(text):
        return "<TAG>" + text + "</TAG>"
%></p>

<p>Here's some tagged text: ${"text" | myescape}
```</p>

<p>Or from any Python module:</p>

<p><code>
&lt;%!
    import myfilters
%&gt;
</code></p>

<p>Here's some tagged text: ${"text" | myfilters.tagfilter}</p>

<p>A page can apply a default set of filters to all expression tags using the <code>expression_filter</code> argument to the <code>%page</code> tag:</p>

<p>```
&lt;%page expression_filter="h"/></p>

<p>Escaped text:  ${"<html>some html</html>"}
```</p>

<p>Result:</p>

<p><code>
Escaped text: &amp;lt;html&amp;gt;some html&amp;lt;/html&amp;gt;
</code></p>

<h3>The <code>default_filters</code> Argument</h3>

<p>The <code>default_filters</code> argument to both <code>Template</code> and <code>TemplateLookup</code> can specify filtering for all expression tags at programmatic level.</p>

<p><code>
t = TemplateLookup(directories=['/tmp'], default_filters=['unicode', 'decode.utf8'])
</code></p>

<p>Since it's not the main focus on programmatic level, skip the rest of this section first.</p>

<h3>Turning off Filtering with the <code>n</code> Filter</h3>

<p>In all cases the special <code>n</code> filter, used locally within an expression, will disable all filters declared in the <code>&lt;%page&gt;</code> tag as well as in <code>default_filters</code>. Such as:</p>

<p><code>
${'myexpression' | n}
</code></p>

<p>will render <code>myexpression</code> with no filtering of any kind, and:</p>

<p><code>
${'myexpression' | n,trim}
</code></p>

<p>will render <code>myexpression</code> using the <code>trim</code> filter only.</p>

<h3>Filtering Defs and Blocks</h3>

<p>For the %def and %block tags have an argument called <code>filter</code>:</p>

<p>&lt;%def name="foo()" filter="h, trim">
    <b>this is bold</b>
</%def></p>

<p>When the <code>filter</code> attribute is applied to a def as above, the def is automatically <strong>buffered</strong> as well. This is described next.</p>

<h3>Buffering</h3>

<p>One of Mako's central design goals is speed, all of the textual content within a template and its various callables is by default piped directly to the single buffer that is stored within the Context object.</p>

<p>But this will have side effect like this:</p>

<p><code>
&lt;%def name="somedef()"&gt;
    somedef's results
&lt;/%def&gt;
</code></p>

<p><code>
${" results " + somedef() + " more results "}
</code></p>

<p>the above template would produce this output:</p>

<p><code>
somedef's results results more results
</code></p>

<p>This is because somedef() fully executes before the expression returns the results of its concatenation; the concatenation in turn receives just the empty string as its middle expression.</p>

<p>Mako provides two ways to work around this. One is by applying buffering to the %def itself:</p>

<p><code>
&lt;%def name="somedef()" buffered="True"&gt;
    somedef's results
&lt;/%def&gt;
</code></p>

<p>Note that the filter argument on %def also causes the def to be buffered.</p>

<p>The other way to buffer the output of a def or any Mako callable is by using the built-in capture function. This function performs an operation similar to the above buffering operation except it is specified by the caller.</p>

<p><code>
${" results " + capture(somedef) + " more results "}
</code></p>

<p>To send arguments to the function, just send them to capture instead:</p>

<p><code>
${capture(somedef, 17, 'hi', use_paging=True)}
</code></p>

<p>The above call is equivalent to the unbuffered call:</p>

<p><code>
${somedef(17, 'hi', use_paging=True)}
</code></p>

<h3>Decorating</h3>

<p>The original intent of this function is to allow the creation of custom cache logic, but there may be other uses as well.</p>

<p>decorator is intended to be used with a regular Python function, such as one defined in a library module. Here we'll illustrate the python function defined in the template for simplicities' sake:</p>

<p>```
&lt;%!
    def bar(fn):
        def decorate(context, <em>args, *</em>kw):
            context.write("BAR")
            fn(<em>args, *</em>kw)
            context.write("BAR")
            return ''
        return decorate
%></p>

<p>&lt;%def name="foo()" decorator="bar">
    this is foo
</%def></p>

<p>${foo()}
```</p>

<p>The above template will return "BAR this is foo BAR". The <code>fun</code> function is the render callable itself and by default will write to the context like <code>context.write('this is foo')</code>.</p>

<p>To capture its output, use the capture() callable in the mako.runtime module (available in templates as just runtime):</p>

<p>```
&lt;%!
    def bar(fn):
        def decorate(context, <em>args, *</em>kw):
            return "BAR" + runtime.capture(context, fn, <em>args, *</em>kw) + "BAR"
        return decorate
%></p>

<p>&lt;%def name="foo()" decorator="bar">
    this is foo
</%def></p>

<p>${foo()}
```</p>

<p>The result outputs by <code>return</code> clause above instead of writing the out to context like <code>context.write('BAR this is foo BAR')</code>.</p>

<p>The decorator can be used with top-level defs as well as nested defs, and blocks too.</p>

<h2><a href="#the-unicode-chapter">The Unicode Chapter</a></h2>

<p>Skip this chapter for now since most notions coming from python unicode, read more on <a href="http://docs.makotemplates.org/en/latest/unicode.html">here</a></p>

<h2><a href="#caching">Caching</a></h2>

<p><strong>Go through this quickly, it's NICE TO HAVE chapter.</strong></p>

<p>Any template or component can be cached using the cache argument to the &lt;%page>, &lt;%def> or &lt;%block> directives:</p>

<p>```
&lt;%page cached="True"/></p>

<p>template text
```</p>

<p>By default, caching requires that the Beaker package be installed on the system, however the mechanism of caching can be customized to use any third party or user defined system – see Cache Plugins.</p>

<p>The caching flag on &lt;%def> tag:</p>

<p><code>
&lt;%def name="mycomp" cached="True" cache_timeout="60"&gt;
    other text
&lt;/%def&gt;
</code></p>

<p>... and equivalently with the &lt;%block> tag, anonymous or named:</p>

<p><code>
&lt;%block cached="True" cache_timeout="60"&gt;
    other text
&lt;/%block&gt;
</code></p>

<h3>Cache Arguments</h3>

<p>Mako has two cache arguments available on tags that are available in all cases. The rest of the arguments available are specific to a backend.</p>

<p>The two generic tags arguments are:</p>

<ul>
<li>cached="True" - enable caching for this &lt;%page>, &lt;%def>, or &lt;%block>.</li>
<li><p>cache<em>key - the "key" used to uniquely identify this content in the cache. Usually, this key is chosen automatically based on the name of the rendering callable. Using the cache</em>key parameter, the key can be overridden using a fixed or programmatically generated value.</p>

<p>For example, here's a page that caches any page which inherits from it, based on the filename of the calling template:</p>

<p>```
&lt;%page cached="True" cache_key="${self.filename}"/></p>

<p>${next.body()}</p>

<p>## rest of template
```</p></li>
</ul>

<p>On a Template or TemplateLookup, the caching can be configured using these arguments:</p>

<ul>
<li>cache_eabnled</li>
<li>cache_impl</li>
<li>cache_args</li>
</ul>

<p>See details <a href="http://docs.makotemplates.org/en/latest/caching.html">here</a></p>

<h3>Backend-Specific Cache Arguments</h3>

<p>The &lt;%page>, &lt;%def>, and &lt;%block> tags accept any named argument that starts with the prefix "cache<em>". Those arguments are then packaged up and passed along to the underlying caching implementation, minus the "cache</em>" prefix.</p>

<h4>Using the Beaker Cache Backend</h4>

<p>When using Beaker, new implementations will want to make usage of cache regions so that cache configurations can be maintained externally to templates. These configurations live under named "regions" that can be referred to within templates themselves.</p>

<p>For example, suppose we would like two regions. One is a "short term" region that will store content in a memory-based dictionary, expiring after 60 seconds. The other is a Memcached region, where values should expire in five minutes. To configure our TemplateLookup, first we get a handle to a beaker.cache.CacheManager:</p>

<p>```
from beaker.cache import CacheManager</p>

<p>manager = CacheManager(cache<em>regions={
    'short</em>term':{
        'type': 'memory',
        'expire': 60
    },
    'long_term':{
        'type': 'ext:memcached',
        'url': '127.0.0.1:11211',
        'expire': 300
    }
})</p>

<p>lookup = TemplateLookup(
                directories=['/path/to/templates'],
                module<em>directory='/path/to/modules',
                cache</em>impl='beaker',
                cache_args={
                    'manager':manager
                }
        )</p>

<p>```
Our templates can then opt to cache data in one of either region, using the cache<em>region argument. Such as using short</em>term at the &lt;%page> level:</p>

<p>```
&lt;%page cached="True" cache<em>region="short</em>term"></p>

<p>## ...
```</p>

<p>Or, long_term at the &lt;%block> level:</p>

<p><code>
&lt;%block name="header" cached="True" cache_region="long_term"&gt;
    other text
&lt;/%block&gt;
</code></p>

<p>The Beaker backend also works without regions. There are a variety of arguments that can be passed to the cache_args dictionary, which are also allowable in templates via the &lt;%page>, &lt;%block>, and &lt;%def> tags specific to those sections. The values given override those specified at the TemplateLookup or Template level.</p>

<p>With the possible exception of <strong>cache<em>timeout</strong>, these arguments are probably better off staying at the template configuration level. Each argument specified as <strong>cache</em>XYZ</strong> in a template tag is specified without the <strong>cache<em></strong> prefix in the <strong>cache</em>args</strong> dictionary:</p>

<ul>
<li>cache<em>timeout - number of seconds in which to invalidate the cached data. After this timeout, the content is re-generated on the next call. Available as timeout in the cache</em>args dictionary.</li>
<li>cache<em>type - type of caching. 'memory', 'file', 'dbm', or 'ext:memcached' (note that the string memcached is also accepted by the dogpile.cache Mako plugin, though not by Beaker itself). Available as type in the cache</em>args dictionary.</li>
<li>cache<em>url - (only used for memcached but required) a single IP address or a semi-colon separated list of IP address of memcache servers to use. Available as url in the cache</em>args dictionary.</li>
<li>cache<em>dir - in the case of the 'file' and 'dbm' cache types, this is the filesystem directory with which to store data files. If this option is not present, the value of module</em>directory is used (i.e. the directory where compiled template modules are stored). If neither option is available an exception is thrown. Available as dir in the cache_args dictionary.</li>
</ul>

<h4>Using the dogpile.cache Backend</h4>

<p>dogpile.cache is a new replacement for Beaker. It provides a modernized, slimmed down interface and is generally easier to use than Beaker. As of this writing it has not yet been released. dogpile.cache includes its own Mako cache plugin --- see dogpile.cache.plugins.mako_cache in the dogpile.cache documentation.</p>

<h3>Programmatic Cache Access</h3>

<p>See details <a href="http://docs.makotemplates.org/en/latest/caching.html">here</a></p>

<h3>Cache Plugins</h3>

<p>See details <a href="http://docs.makotemplates.org/en/latest/caching.html">here</a></p>

<h3>Guidelines for Writing Cache Plugins</h3>

<p>See details <a href="http://docs.makotemplates.org/en/latest/caching.html">here</a></p>

<h3>API Reference</h3>

<p>See details <a href="http://docs.makotemplates.org/en/latest/caching.html">here</a></p>
