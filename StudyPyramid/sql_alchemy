SQLAlchemy ORM

[BEGIN: Object Relational Tutorial]

Version Check

	>>> import sqlalchemy
	>>> sqlalchemy.__version__
	0.7.0


Connecting

	>>> from sqlalchemy import create_engine
	>>> engine = create_engine('sqlite:///:memory:', echo=True)

	"echo=True" means generated SQL produced.


Declare a Mapping

	>>> from sqlalchemy.ext.declarative import declarative_base

	>>> Base = declarative_base()
	>>> class User(Base):
	...     __tablename__ = 'users'
	...
	...     id = Column(Integer, primary_key=True)
	...     name = Column(String)
	...     fullname = Column(String)
	...     password = Column(String)
	...
	...     def __init__(self, name, fullname, password):
	...         self.name = name
	...         self.fullname = fullname
	...         self.password = password
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)

	The underlying Table object created by our declarative_base() version of User is accessible via the __table__ attribute:

	>>> users_table = User.__table__

	While rarely needed, making available the Mapper object via the __mapper__ attribute:

	>>> mapper = User.__mapper__

	The owning MetaData object is available as well:

	>>> Base.metadata.create_all(engine)

	PRAGMA table_info("users")
	()
	CREATE TABLE users (
		id INTEGER NOT NULL,
		name VARCHAR,
		fullname VARCHAR,
		password VARCHAR,
		PRIMARY KEY (id)
	)
	()
	COMMIT

	Call create_all() and passing it the engine instance which points to our database to create table, this will check for the presence of a table first before creating, so it’s safe to call multiple times.

	To make sure the "users" table above will be created, just make sure "User" along with "Base" object exist in the current namespace because "Base.metadata.create_all(engine)" hasn't explicitly indicated the "users" table should be created, but it still knows.

	If you see issue when creating table, it could be the target db requires "length" to the String type as below:
	name = Column(String(50))

	For oracle sequence:
	id = Column(Integer, Sequence('user_id_seq'), primary_key=True)


Create an Instance of the Mapped Class

	With mappings complete, let's now create and inspect a User object:

	>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
	>>> ed_user.name
	'ed'
	>>> ed_user.password
	'edspassword'
	>>> str(ed_user.id)
	'None'

	Since we have not yet told SQLAlchemy to persist Ed Jones within the database, its id is None. And User class doesn't define "id" attribute, but users_table does, so we have "id" here.


Creating a Session

	The ORM’s “handle” to the database is the Session.

	>>> from sqlalchemy.orm import sessionmaker
	>>> Session = sessionmaker(bind=engine)

	In the case where your application does not yet have an Engine when you define your module-level objects, just set it up like this:

	>>> Session = sessionmaker()

	Later, when you create your engine with create_engine(), connect it to the Session using configure():

	>>> Session.configure(bind=engine)  # once engine is available

	Then, whenever you need to have a conversation with the database, you instantiate a Session:

	>>> session = Session()

	The above Session is associated with our SQLite-enabled Engine, but it hasn’t opened any connections yet. When it’s first used, it retrieves a connection from a pool of connections maintained by the Engine, and holds onto it until we commit all changes and/or close the session object.


Adding new Objects

To persist our User object, we add() it to our Session:

	>>> ed_user = User('ed', 'Ed Jones', 'edspassword')
	>>> session.add(ed_user)

	At this point, we say that the instance is pending; no SQL has yet been issued and the object is not yet represented by a row in the database. The Session will issue the SQL to persist Ed Jones as soon as is needed, using a process known as a flush. If we query the database for Ed Jones, all pending information will first be flushed, and the query is issued immediately thereafter.

	For example, below we create a new Query object which loads instances of User. We “filter by” the name attribute of ed, and indicate that we’d like only the first result in the full list of rows. A User instance is returned which is equivalent to that which we’ve added:

	sql>>> our_user = session.query(User).filter_by(name='ed').first()
	BEGIN (implicit)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('ed', 'Ed Jones', 'edspassword')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ?
	 LIMIT 1 OFFSET 0
	('ed',)
	>>> our_user
	<User('ed','Ed Jones', 'edspassword')>

	In fact, the Session has identified that the row returned is the same row as one already represented within its internal map of objects, so we actually got back the identical instance as that which we just added:

	>>> ed_user is our_user
	True

	We can add more User objects at once using add_all():

	>>> session.add_all([
	...     User('wendy', 'Wendy Williams', 'foobar'),
	...     User('mary', 'Mary Contrary', 'xxg527'),
	...     User('fred', 'Fred Flinstone', 'blah')])

	Also, Ed has already decided his password isn’t too secure, so lets change it:

	>>> ed_user.password = 'f8s7ccs'

	The Session is paying attention. It knows, for example, that Ed Jones has been modified:

	>>> session.dirty
	IdentitySet([<User('ed','Ed Jones', 'f8s7ccs')>])

	and that three new User objects are pending:

	>>> session.new
	IdentitySet([<User('wendy','Wendy Williams', 'foobar')>,
	<User('mary','Mary Contrary', 'xxg527')>,
	<User('fred','Fred Flinstone', 'blah')>])

	We tell the Session that we’d like to issue all remaining changes to the database and commit the
	transaction, which has been in progress throughout. We do this via commit():

	sql>>> session.commit()
	UPDATE users SET password=? WHERE users.id = ?
	('f8s7ccs', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('wendy', 'Wendy Williams', 'foobar')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('mary', 'Mary Contrary', 'xxg527')
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fred', 'Fred Flinstone', 'blah')
	COMMIT

	commit() flushes whatever remaining changes remain to the database, and commits the transaction. The connection resources referenced by the session are now returned to the connection pool. Subsequent operations with this session will occur in a new transaction, which will again re-acquire connection resources when first needed.

	If we look at Ed’s id attribute, which earlier was None, it now has a value:

	sql>>> ed_user.id
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	1

	After the Session inserts new rows in the database, all newly generated identifiers and database-generated defaults become available on the instance, either immediately or via load-on-first-access. In this case, the entire row was re-loaded on access because a new transaction was begun after we issued commit(). SQLAlchemy by default refreshes data from a previous transaction the first time it’s accessed within a new transaction, so that the most recent state is available. The level of reloading is configurable as is described in the chapter on Sessions.


Rolling Back

	Since the Session works within a transaction, we can roll back changes made too. Let’s make two
changes that we’ll revert; ed_user‘s user name gets set to Edwardo:

	>>> ed_user.name = 'Edwardo'

	and we’ll add another erroneous user, fake_user:

	>>> fake_user = User('fakeuser', 'Invalid', '12345')
	>>> session.add(fake_user)

	Querying the session, we can see that they’re flushed into the current transaction:

	sql>>> session.query(User).filter(User.name.in_(['Edwardo', 'fakeuser'])).all()
	UPDATE users SET name=? WHERE users.id = ?
	('Edwardo', 1)
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('fakeuser', 'Invalid', '12345')
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name IN (?, ?)
	('Edwardo', 'fakeuser')
	[<User('Edwardo','Ed Jones', 'f8s7ccs')>, <User('fakeuser','Invalid', '12345')>]

	Rolling back, we can see that ed_user‘s name is back to ed, and fake_user has been kicked out of the session:

	sql>>> session.rollback()
	ROLLBACK

	sql>>> ed_user.name
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.id = ?
	(1,)
	u'ed'
	>>> fake_user in session
	False


Querying

	1. Query class, return a list of users:

	sql>>> for instance in session.query(User).order_by(User.id):
	...     print instance.name, instance.fullname
	SELECT users.id AS users_id, users.name AS users_name,
	users.fullname AS users_fullname, users.password AS users_password
	FROM users ORDER BY users.id
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	2. Query fields on class, return a tuples:

	sql>>> for name, fullname in session.query(User.name, User.fullname):
	...     print name, fullname
	SELECT users.name AS users_name, users.fullname AS users_fullname
	FROM users
	()
	ed Ed Jones
	wendy Wendy Williams
	mary Mary Contrary
	fred Fred Flinstone

	3. The tuples returned by Query are named tuples, and can be treated much like an ordinary Python object.

	sql>>> for row in session.query(User, User.name).all():
	...    print row.User, row.name

	4.  You can control the names using the label() construct for scalar attributes and aliased for class constructs:
	>>> from sqlalchemy.orm import aliased
	>>> user_alias = aliased(User, name='user_alias')
	sql>>> for row in session.query(user_alias, user_alias.name.label('name_label')).all():
	...    print row.user_alias, row.name_label
	It has the same side effective with the point 3 above, but with alias class and attribute.

	5. LIMIT and OFFSET, with ORDER BY:

	sql>>> for u in session.query(User).order_by(User.id)[1:3]:
	...    print u
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users ORDER BY users.id
	LIMIT 2 OFFSET 1
	()
	<User('wendy','Wendy Williams', 'foobar')>
	<User('mary','Mary Contrary', 'xxg527')>

	6. Filtering results: 

	sql>>> for name, in session.query(User.name).filter_by(fullname='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	e

	sql>>> for name, in session.query(User.name).filter(User.fullname=='Ed Jones'):
	...    print name
	SELECT users.name AS users_name FROM users
	WHERE users.fullname = ?
	('Ed Jones',)
	ed

	sql>>> for user in session.query(User).filter(User.name=='ed').filter(User.fullname=='Ed Jones'):
	...    print user
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.passwor
	FROM users
	WHERE users.name = ? AND users.fullname = ?
	('ed', 'Ed Jones')
	<User('ed','Ed Jones', 'f8s7ccs')>


Common Filter Operators

	Here’s a rundown of some of the most common operators used in filter():

	• equals:

	query.filter(User.name == 'ed')

	• not equals:

	query.filter(User.name != 'ed')

	• LIKE:

	query.filter(User.name.like('%ed%'))

	• IN:

	query.filter(User.name.in_(['ed', 'wendy', 'jack']))

	# works with query objects too:

	query.filter(User.name.in_(session.query(User.name).filter(User.name.like('%ed%'))))

	• NOT IN:

	query.filter(~User.name.in_(['ed', 'wendy', 'jack']))

	• IS NULL:

	filter(User.name == None)

	• IS NOT NULL:

	filter(User.name != None)

	• AND:

	from sqlalchemy import and_
	filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))

	# or call filter()/filter_by() multiple times
	filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')

	• OR:

	from sqlalchemy import or_
	filter(or_(User.name == 'ed', User.name == 'wendy'))

	• match:

	query.filter(User.name.match('wendy'))

	The contents of the match parameter are database backend specific.


Returning Lists and Scalars

	The all(), one(), and first() methods of Query immediately issue SQL and return a non-iterator value. all() returns a list:

	1. 
	>>> query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)
	sql>>> query.all()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	('%ed',)
	[<User('ed','Ed Jones', 'f8s7ccs')>, <User('fred','Fred Flinstone', 'blah')>]

	2. 
	first() applies a limit of one and returns the first result as a scalar:

	sql>>> query.first()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	LIMIT 1 OFFSET 0
	('%ed',)
	<User('ed','Ed Jones', 'f8s7ccs')>

	3.
	one(), fully fetches all rows, and if not exactly one object identity or composite row is present in the result, raises an error:

	sql>>> from sqlalchemy.orm.exc import MultipleResultsFound
	>>> try:
	...     user = query.one()
	... except MultipleResultsFound, e:
	...     print e
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fu
	FROM users
	WHERE users.name LIKE ? ORDER BY users.id
	('%ed',)
	Multiple rows were found for one()

	sql>>> from sqlalchemy.orm.exc import NoResultFound
	>>> try:
	...     user = query.filter(User.id == 99).one()
	... except NoResultFound, e:
	...     print e
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS user
	FROM users
	WHERE users.name LIKE ? AND users.id = ? ORDER BY users.id
	('%ed', 99)
	No row was found for one()


Using Literal SQL

	1.  Most methods accept strings in addition to SQLAlchemy clause constructs. For example, filter() and order_by():

	sql>>> for user in session.query(User).filter("id<224").order_by("id").all():
	...     print user.name
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE id<224 ORDER BY id
	()
	ed
	wendy
	mary
	fred

	2. Bind parameters can be specified with string-based SQL, using a colon. To specify the values, use the params() method:

	sql>>> session.query(User).filter("id<:value and name=:name").\
	...     params(value=224, name='fred').order_by(User.id).one()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE id<User('fred','Fred Flinstone', 'blah')>

	3. To use an entirely string-based statement:

	sql>>> session.query(User).from_statement(
	...                     "SELECT * FROM users where name=:name").\
	...                     params(name='ed').all()
	SELECT * FROM users where name=?
	('ed',)
	[<User('ed','Ed Jones', 'f8s7ccs')>]

	4. You can use from_statement() to go completely “raw”, using string names to identify desired columns:

	sql>>> session.query("id", "name", "thenumber12").\
	...         from_statement("SELECT id, name, 12 as "
	...                 "thenumber12 FROM users where name=:name").\
	...                 params(name='ed').all()
	SELECT id, name, 12 as thenumber12 FROM users where name=?
	('ed',)
	[(1, u'ed', 12)]


Counting

	1. For simple count: Query includes a convenience method for counting called count():

	sql>>> session.query(User).filter(User.name.like('%ed')).count()
	SELECT count(1) AS count_1
	FROM users
	WHERE users.name LIKE ?
	('%ed',)
	2

	2. For more complicated count:

	Use the func.count() function as a column expression:

	>>> from sqlalchemy import func
	sql>>> session.query(func.count(User.name), User.name).group_by(User.name).all()
	SELECT count(users.name) AS count_1, users.name AS users_name
	FROM users GROUP BY users.name
	()
	[(1, u'ed'), (1, u'fred'), (1, u'mary'), (1, u'wendy')]


Building a Relationship

	Using declarative, we define this table along with its mapped class, Address:

	>>> from sqlalchemy import ForeignKey
	>>> from sqlalchemy.orm import relationship, backref
	>>> class Address(Base):
	...
	...     __tablename__ = 'addresses'
	...
	...     id = Column(Integer, primary_key=True)
	...     email_address = Column(String, nullable=False)
	...     user_id = Column(Integer, ForeignKey('users.id'))
	...
	...     user = relationship(User, backref=backref('addresses', order_by=id))
	...
	...     # if you have multiple foreign keys between User and Address, add primaryjoin like this, otherwise, sqlalchemy wonder which foreign key is specified to join:
	...     # user = relationship(User, backref=backref('addresses', order_by=id), primaryjoin=Address.user_id==User.id)
	...     # user2 = relationship(User, backref=backref('addresses2', order_by=id), primaryjoin=Address.user_id2==User.id)
	...
	...     def __init__(self, email_address):
	...         self.email_address = email_address
	...
	...     def __repr__(self):
	...         return "<Address('%s')>" % self.email_address

	The relationship between the User and Address classes is defined separately using the relationship() function, which defines an attribute user to be placed on the Address class, as well as an addresses collection to be placed on the User class. SQLAlchemy is automatically aware of many-to-one/one-to-many based on foreign keys.

	class User(Base):
	# ....
	addresses = relationship(Address, order_by=Address.id, backref="user")

	[We are also free to not define a backref, and to define the relationship() only on one class and not the other.](means you don't have to have "addresses" defined in class User) It is also possible to define two separate relationship() constructs for either direction, which is generally safe for many-to-one and one-to-many relationships, but not for many-to-many relationships.

	When using the declarative extension, relationship() gives us the option to use strings for most arguments that concern the target class, in the case that the target class has not yet been defined. This only works in conjunction with declarative:

	class User(Base):
	....
	addresses = relationship("Address", order_by="Address.id", backref="user")

	We’ll need to create the addresses table in the database, so we will issue another CREATE from our metadata, which will skip over tables which have already
	been created:

	sql>>> metadata.create_all(engine)
	PRAGMA table_info("users")
	()
	PRAGMA table_info("addresses")
	()
	CREATE TABLE addresses (
	id INTEGER NOT NULL,
	email_address VARCHAR NOT NULL,
	user_id INTEGER,
	PRIMARY KEY (id),
	FOREIGN KEY(user_id) REFERENCES users (id)
	)
	()
	COMMIT


Working with Related Objects

	>>> jack = User('jack', 'Jack Bean', 'gjffdd')
	>>> jack.addresses
	[]

	>>> jack.addresses = [Address(email_address='jack@google.com'), Address(email_address='j25@yahoo.com')]

	When using a bidirectional relationship, elements added in one direction automatically become visible in the other direction. This is the basic behavior of the backref keyword, which maintains the relationship purely in memory, without using any SQL:

	>>> jack.addresses[1]
	<Address('j25@yahoo.com')>

	>>> jack.addresses[1].user
	<User('jack','Jack Bean', 'gjffdd')>

	>>> session.add(jack)
	sql>>> session.commit()
	INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
	('jack', 'Jack Bean', 'gjffdd')
	INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
	('jack@google.com', 5)
	INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
	('j25@yahoo.com', 5)
	COMMIT

	Querying for Jack, we get just Jack back. No SQL is yet issued for Jack’s addresses:

	sql>>> jack = session.query(User).filter_by(name='jack').one()
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE users.name = ?
	('jack',)
	>>> jack
	<User('jack','Jack Bean', 'gjffdd')>

	sql>>> jack.addresses
	SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM addresses
	WHERE ? = addresses.user_id ORDER BY addresses.id
	(5,)
	[<Address('jack@google.com')>, <Address('j25@yahoo.com')>]

	This is an example of a lazy loading relationship, check out "Eager Loading" to see the solution.


Querying with Joins

	While joinedload() created a JOIN specifically to populate a collection, we can also work explicitly with joins in many ways.

	sql>>> for u, a in session.query(User, Address).filter(User.id==Address.user_id).\
	...         filter(Address.email_address=='jack@google.com').all():
	...     print u, a
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, addresses.id AS addresses_id,
	addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM users, addresses
	WHERE users.id = addresses.user_id AND addresses.email_address = ?
	('jack@google.com',)
	<User('jack','Jack Bean', 'gjffdd')> <Address('jack@google.com')>

	Or we can make a real JOIN construct; the most common way is to use join():

	sql>>> session.query(User).join(Address).\
	...         filter(Address.email_address=='jack@google.com').all()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users JOIN addresses ON users.id = addresses.user_id
	WHERE addresses.email_address = ?
	('jack@google.com',)
	[<User('jack','Jack Bean', 'gjffdd')>]

	join() knows how to join between User and Address because there’s only one foreign key between them.
	If there were no foreign keys, or several, join() works better when one of the following forms are used:

	query.join(Address, User.id==Address.user_id)  # explicit condition
	query.join(User.addresses)                     # specify relationship from left to right
	query.join(Address, User.addresses)            # same, with explicit target
	query.join('addresses')                        # same, using a string

	This is so that multiple joins can be chained together, as in:

	session.query(Foo).join(
	Foo.bars,
	(Bat, bar.bats),
	(Widget, Bat.widget_id==Widget.id)  # This is one widget to many bats, or means one bat to one widget, not like the relations above.
	)

	The above would produce SQL something like foo JOIN bars ON <onclause> JOIN bats ON <onclause> JOIN widget ON <onclause>.

	As you would expect, the same idea is used for 'outer' joins, using the outerjoin() function:

	query.outerjoin(User.addresses) # LEFT OUTER JOIN


Using Aliases

	Below we join to the Address entity twice, to locate a user who has two distinct email addresses at the same time:
	>>> from sqlalchemy.orm import aliased
	>>> adalias1 = aliased(Address)
	>>> adalias2 = aliased(Address)
	sql>>> for username, email1, email2 in \
	...     session.query(User.name, adalias1.email_address, adalias2.email_address).\
	...     join(adalias1, User.addresses).join(adalias2, User.addresses).\
	...     filter(adalias1.email_address=='jack@google.com').\
	...     filter(adalias2.email_address=='j25@yahoo.com'):
	...     print username, email1, email2
	SELECT users.name AS users_name, addresses_1.email_address AS addresses_1_email_address,
	addresses_2.email_address AS addresses_2_email_address
	FROM users JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
	JOIN addresses AS addresses_2 ON users.id = addresses_2.user_id
	WHERE addresses_1.email_address = ? AND addresses_2.email_address = ?
	('jack@google.com', 'j25@yahoo.com')
	jack jack@google.com j25@yahoo.com


Using Subqueries

	Suppose we wanted to load User objects along with a count of how many Address records each user has.

	SELECT users.*, adr_count.address_count FROM users LEFT OUTER JOIN
	(SELECT user_id, count(*) AS address_count FROM addresses GROUP BY user_id) AS adr_count
	ON users.id=adr_count.user_id

	>>> from sqlalchemy.sql import func
	>>> stmt = session.query(Address.user_id, func.count('*').label('address_count')).group_by(Address.user_id).subquery()

	The func keyword generates SQL functions, and the subquery() method on Query produces a SQL expression construct representing a SELECT statement embedded within an alias (it’s actually shorthand for
	query.statement.alias()).

	Once we have our statement, it behaves like a Table construct. The columns on the statement are accessible through an attribute called c:

	sql>>> for u, count in session.query(User, stmt.c.address_count).\
	...     outerjoin((stmt, User.id==stmt.c.user_id)).order_by(User.id):
	...     print u, count
	SELECT users.id AS users_id, users.name AS users_name,
	users.fullname AS users_fullname, users.password AS users_password,
	anon_1.address_count AS anon_1_address_count
	FROM users LEFT OUTER JOIN (SELECT addresses.user_id AS user_id, count(?) AS address_count
	FROM addresses GROUP BY addresses.user_id) AS anon_1 ON users.id = anon_1.user_id
	ORDER BY users.id
	('*',)
	<User('ed','Ed Jones', 'f8s7ccs')> None
	<User('wendy','Wendy Williams', 'foobar')> None
	<User('mary','Mary Contrary', 'xxg527')> None
	<User('fred','Fred Flinstone', 'blah')> None
	<User('jack','Jack Bean', 'gjffdd')> 2


Selecting Entities from Subqueries

	Above, we just selected a result that included a column from a subquery. What if we wanted our subquery to map to an entity ? For this we use aliased() to associate an “alias” of a mapped class to a
	subquery:

	sql>>> stmt = session.query(Address).filter(Address.email_address != 'j25@yahoo.com').subquery()
	>>> adalias = aliased(Address, stmt)
	>>> for user, address in session.query(User, adalias).join(adalias, User.addresses): # like "for user, address in session.query(User, Address).join(Address, User.addresses):"
	...     print user, address
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, anon_1.id AS anon_1_id,
	anon_1.email_address AS anon_1_email_address, anon_1.user_id AS anon_1_user_id
	FROM users JOIN (SELECT addresses.id AS id, addresses.email_address AS email_address, addresses.user_id AS user_id
	FROM addresses
	WHERE addresses.email_address != ?) AS anon_1 ON users.id = anon_1.user_id
	('j25@yahoo.com',)
	<User('jack','Jack Bean', 'gjffdd')> <Address('jack@google.com')>


Using EXISTS

	The EXISTS keyword in SQL is a boolean operator which returns True if the given expression contains any rows.(But it seems EXISTS can be replaced by JOIN in SQL? NO! It doesn't!)

	>>> from sqlalchemy.sql import exists
	>>> stmt = exists().where(Address.user_id==User.id)
	sql>>> for name, in session.query(User.name).filter(stmt):
	...     print name
	SELECT users.name AS users_name
	FROM users
	WHERE EXISTS (SELECT *
	FROM addresses
	WHERE addresses.user_id = users.id)
	()
	jack

	The Query features several operators which make usage of EXISTS automatically. Above, the statement can be expressed along the User.addresses relationship using any():

	sql>>> for name, in session.query(User.name).filter(User.addresses.any()):
	...     print name
	SELECT users.name AS users_name
	FROM users
	WHERE EXISTS (SELECT 1
	FROM addresses
	WHERE users.id = addresses.user_id)
	()
	jack

	any() takes criterion as well, to limit the rows matched:
	sql>>> for name, in session.query(User.name).\
	...     filter(User.addresses.any(Address.email_address.like('%google%'))):
	...     print name
	SELECT users.name AS users_name
	FROM users
	WHERE EXISTS (SELECT 1
	FROM addresses
	WHERE users.id = addresses.user_id AND addresses.email_address LIKE ?)
	('%google%',)
	jack

	has() is the same operator as any() for many-to-one relationships (note the ~ operator here too, which means “NOT”):

	sql>>> session.query(Address).filter(~Address.user.has(User.name=='jack')).all()
	SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address,
	addresses.user_id AS addresses_user_id
	FROM addresses
	WHERE NOT (EXISTS (SELECT 1
	FROM users
	WHERE users.id = addresses.user_id AND users.name = ?))
	('jack',)
	[]


Common Relationship Operators

	Here’s all the operators which build on relationships:

	• equals (used for many-to-one):

		query.filter(Address.user == someuser)

	• not equals (used for many-to-one):

		query.filter(Address.user != someuser)

	• IS NULL (used for many-to-one):

		query.filter(Address.user == None)

	• contains (used for one-to-many and many-to-many collections):

		query.filter(User.addresses.contains(someaddress))

	• any (used for one-to-many and many-to-many collections):

		query.filter(User.addresses.any(Address.email_address == 'bar'))

		# also takes keyword arguments:
		query.filter(User.addresses.any(email_address='bar'))

	• has (used for many-to-one):

		query.filter(Address.user.has(User.name == 'ed'))
		Or
		query.filter(Address.user.has(name='ed'))

	• with_parent (used for any relationship):

		session.query(Address).with_parent(someuser, 'addresses')


Eager Loading

	1) Joined Load

	To reduce the number of queries, apply an eager load to the query operation, using the joinedload() function.
	SQLAlchemy then constructs an outer join between the users and addresses tables, and loads them at once, populating the addresses collection on each User object if it’s not already populated:

	>>> from sqlalchemy.orm import joinedload

	sql>>> jack = session.query(User).\
	...                        options(joinedload('addresses')).\
	...                        filter_by(name='jack').one()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, addresses_1.id AS addresses_1_id, addresses_1.email_address
	AS addresses_1_email_address, addresses_1.user_id AS addresses_1_user_id
	FROM users LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
	WHERE users.name = ? ORDER BY addresses_1.id
	('jack',)
	>>> jack
	<User('jack','Jack Bean', 'gjffdd')>

	>>> jack.addresses
	[<Address('jack@google.com')>, <Address('j25@yahoo.com')>]

	Check out joinedload() and subqueryload() in documentation.

	2) Explicit Join + Eagerload

	join() or an equivalent + contains_eager() option = joinedload()

	means join tables first, then loading related entity onto the resulting resutls in one step instead of addtional queries and 'automatic' join embedded by the joinedload() function:

	>>> from sqlalchemy.orm import contains_eager
	sql>>> for address in session.query(Address).\
	...                join(Address.user).\
	...                filter(User.name=='jack').\
	...                options(contains_eager(Address.user)):
	...         print address, address.user
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname,
	users.password AS users_password, addresses.id AS addresses_id,
	addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM addresses JOIN users ON users.id = addresses.user_id
	WHERE users.name = ?
	('jack',)
	<Address('jack@google.com')> <User('jack','Jack Bean', 'gjffdd')>
	<Address('j25@yahoo.com')> <User('jack','Jack Bean', 'gjffdd')>


Deleting

	Let’s try to delete jack and see how that goes. We’ll mark as deleted in the session, then we’ll issue a count query to see that no rows remain:

	>>> session.delete(jack)
	sql>>> session.query(User).filter_by(name='jack').count()
	UPDATE addresses SET user_id=? WHERE addresses.id = ?
	(None, 1)
	UPDATE addresses SET user_id=? WHERE addresses.id = ?
	(None, 2)
	DELETE FROM users WHERE users.id = ?
	(5,)
	SELECT count(1) AS count_1
	FROM users
	WHERE users.name = ?
	('jack',)
	0

	So far, so good. How about Jack’s Address objects ?

	sql>>> session.query(Address).filter(
	...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
	...  ).count()
	SELECT count(1) AS count_1
	FROM addresses
	WHERE addresses.email_address IN (?, ?)
	('jack@google.com', 'j25@yahoo.com')
	2

	Uh oh, they’re still there ! Analyzing the flush SQL, we can see that the user_id column of each address was set to NULL, but the rows weren’t deleted. SQLAlchemy doesn’t assume that deletes cascade, you have to tell it to do so.  


Configuring delete/delete-orphan Cascade

	We will configure cascade options on the User.addresses relationship to change the behavior.

	>>> session.close()  # roll back and close the transaction

	The User.addresses relationship now has delete, delete-orphan cascade on it, which indicates that DELETE operations will cascade to attached Address objects as well as Address objects which are removed from their parent:

	and use a new declarative_base():

	>>> Base = declarative_base()

	Next we’ll declare the User class, adding in the addresses relationship including the cascade configuration (we’ll leave the constructor out too):

	>>> class User(Base):
	...     __tablename__ = 'users'
	...
	...     id = Column(Integer, primary_key=True)
	...     name = Column(String)
	...     fullname = Column(String)
	...     password = Column(String)
	...
	...     addresses = relationship(Address, backref='user', cascade="all, delete, delete-orphan")
	...
	...     def __repr__(self):
	...        return "<User('%s','%s', '%s')>" % (self.name, self.fullname, self.password)

	Now when we load Jack (below using get(), which loads by primary key), removing an address from his addresses collection will result in that Address being deleted:

	# load Jack by primary key
	sql>>> jack = session.query(User).get(5)
	BEGIN (implicit)
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE users.id = ?
	(5,)

	# remove one Address (lazy load fires off)
	sql>>> del jack.addresses[1]
	SELECT addresses.id AS addresses_id, addresses.email_address AS addresses_email_address, addresses.user_id AS addresses_user_id
	FROM addresses
	WHERE ? = addresses.user_id
	(5,)

	# only one address remains
	sql>>> session.query(Address).filter(
	...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
	... ).count()
	DELETE FROM addresses WHERE addresses.id = ?
	(2,)
	SELECT count(1) AS count_1
	FROM addresses
	WHERE addresses.email_address IN (?, ?)
	('jack@google.com', 'j25@yahoo.com')
	1

	Deleting Jack will delete both Jack and his remaining Address:

	>>> session.delete(jack)
	sql>>> session.query(User).filter_by(name='jack').count()
	DELETE FROM addresses WHERE addresses.id = ?
	(1,)
	DELETE FROM users WHERE users.id = ?
	(5,)
	SELECT count(1) AS count_1
	FROM users
	WHERE users.name = ?
	('jack',)
	0

	sql>>> session.query(Address).filter(
	...    Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
	... ).count()
	SELECT count(1) AS count_1
	FROM addresses
	WHERE addresses.email_address IN (?, ?)
	('jack@google.com', 'j25@yahoo.com')
	0


Building a Many To Many Relationship

	We’ll make our application a blog application, where users can write BlogPost items, which have Keyword items associated with them.

	The declarative setup is as follows:

	>>> from sqlalchemy import Table, Text

	>>> # association table
	>>> post_keywords = Table('post_keywords', metadata,
	...     Column('post_id', Integer, ForeignKey('posts.id')),
	...     Column('keyword_id', Integer, ForeignKey('keywords.id'))
	... )

	>>> class BlogPost(Base):
	...     __tablename__ = 'posts'
	...
	...     id = Column(Integer, primary_key=True)
	...     user_id = Column(Integer, ForeignKey('users.id'))
	...     headline = Column(String(255), nullable=False)
	...     body = Column(Text)
	...
	...     # many to many BlogPost<->Keyword
	...     keywords = relationship('Keyword', secondary=post_keywords, backref='posts')
	...
	...     def __init__(self, headline, body, author):
	...         self.author = author
	...         self.headline = headline
	...         self.body = body
	...
	...     def __repr__(self):
	...         return "BlogPost(%r, %r, %r)" % (self.headline, self.body, self.author)

	>>> class Keyword(Base):
	...     __tablename__ = 'keywords'
	...
	...     id = Column(Integer, primary_key=True)
	...     keyword = Column(String(50), nullable=False, unique=True)
	...
	...     def __init__(self, keyword):
	...         self.keyword = keyword

	Above, the many-to-many relationship is BlogPost.keywords. The defining feature of a many-to-many relationship is the secondary keyword argument which references a Table object representing the association table. This table only contains columns which reference the two sides of the relationship; if it has any other columns, such as its own primary key, or foreign keys to other tables, SQLAlchemy requires a different usage pattern called the “association object”, described at Association Object.

	We would also like our BlogPost class to have an author field. We will add this as another bidirectional relationship, except one issue we’ll have is that a single user might have lots of blog posts. When we access User.posts, we'd like to be able to filter results further so as not to load the entire collection. For this we use a setting accepted by relationship() called lazy='dynamic', which configures an alternate loader strategy on the attribute(see samples in ./test_sqlalchemy.py). To use it on the “reverse” side of a relationship(), we use the backref() function:

	>>> from sqlalchemy.orm import backref
	>>> # "dynamic" loading relationship to User
	>>> BlogPost.author = relationship(User, backref=backref('posts', lazy='dynamic'))

	Create new tables:

	sql>>> Base.metadata.create_all(engine)
	PRAGMA table_info("users")
	()
	PRAGMA table_info("addresses")
	()
	PRAGMA table_info("posts")
	()
	PRAGMA table_info("keywords")
	()
	PRAGMA table_info("post_keywords")
	()
	CREATE TABLE posts (
	id INTEGER NOT NULL,
	user_id INTEGER,
	headline VARCHAR(255) NOT NULL,
	body TEXT,
	PRIMARY KEY (id),
	FOREIGN KEY(user_id) REFERENCES users (id)
	)
	()
	COMMIT
	CREATE TABLE keywords (
	id INTEGER NOT NULL,
	keyword VARCHAR(50) NOT NULL,
	PRIMARY KEY (id),
	UNIQUE (keyword)
	)
	()
	COMMIT
	CREATE TABLE post_keywords (
	post_id INTEGER,
	keyword_id INTEGER,
	FOREIGN KEY(post_id) REFERENCES posts (id),
	FOREIGN KEY(keyword_id) REFERENCES keywords (id)
	)
	()
	COMMIT

	Usage is not too different from what we’ve been doing. Let’s give Wendy some blog posts:

	sql>>> wendy = session.query(User).filter_by(name='wendy').one()
	SELECT users.id AS users_id, users.name AS users_name, users.fullname AS users_fullname, users.password AS users_password
	FROM users
	WHERE users.name = ?
	('wendy',)
	>>> post = BlogPost("Wendy's Blog Post", "This is a test", wendy)
	>>> session.add(post)

	We’re storing keywords uniquely in the database, but we know that we don’t have any yet, so we can just create them:

	>>> post.keywords.append(Keyword('wendy'))
	>>> post.keywords.append(Keyword('firstpost'))

	We can now look up all blog posts with the keyword ‘firstpost’. We’ll use the any operator to locate “blog posts where any of its keywords has the keyword string ‘firstpost’”:

	sql>>> session.query(BlogPost).filter(BlogPost.keywords.any(keyword='firstpost')).all()
	INSERT INTO keywords (keyword) VALUES (?)
	('wendy',)
	INSERT INTO keywords (keyword) VALUES (?)
	('firstpost',)
	INSERT INTO posts (user_id, headline, body) VALUES (?, ?, ?)
	(2, "Wendy's Blog Post", 'This is a test')
	INSERT INTO post_keywords (post_id, keyword_id) VALUES (?, ?)
	((1, 1), (1, 2))
	SELECT posts.id AS posts_id, posts.user_id AS posts_user_id, posts.headline AS posts_headline, posts.body AS posts_body
	FROM posts
	WHERE EXISTS (SELECT 1
	FROM post_keywords, keywords
	WHERE posts.id = post_keywords.post_id AND keywords.id = post_keywords.keyword_id AND keywords.keyword = ?)
	('firstpost',)
	[BlogPost("Wendy's Blog Post", 'This is a test', <User('wendy','Wendy Williams', 'foobar')>)]

	If we want to look up just Wendy’s posts, we can tell the query to narrow down to her as a parent:

	sql>>> session.query(BlogPost).filter(BlogPost.author==wendy).\
	... filter(BlogPost.keywords.any(keyword='firstpost')).all()
	SELECT posts.id AS posts_id, posts.user_id AS posts_user_id, posts.headline AS posts_headline, posts.body AS posts_body
	FROM posts
	WHERE ? = posts.user_id AND (EXISTS (SELECT 1
	FROM post_keywords, keywords
	WHERE posts.id = post_keywords.post_id AND keywords.id = post_keywords.keyword_id AND keywords.keyword = ?))
	(2, 'firstpost')
	[BlogPost("Wendy's Blog Post", 'This is a test', <User('wendy','Wendy Williams', 'foobar')>)]

	Or we can use Wendy’s own posts relationship, which is a “dynamic” relationship, to query straight from there:

	sql>>> wendy.posts.filter(BlogPost.keywords.any(keyword='firstpost')).all()
	SELECT posts.id AS posts_id, posts.user_id AS posts_user_id, posts.headline AS posts_headline, posts.body AS posts_body
	FROM posts
	WHERE ? = posts.user_id AND (EXISTS (SELECT 1
	FROM post_keywords, keywords
	WHERE posts.id = post_keywords.post_id AND keywords.id = post_keywords.keyword_id AND keywords.keyword = ?))
	(2, 'firstpost')
	[BlogPost("Wendy's Blog Post", 'This is a test', <User('wendy','Wendy Williams', 'foobar')>)]

