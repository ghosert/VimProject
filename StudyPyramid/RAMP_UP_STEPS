First Pyramid Application:
1. start it:
	~/devenv/bin/python helloworld.py
	OR
	source ~/devenv/bin/activate && python helloworld.py
2. visit it:
	http://localhost:8080/
	http://localhost:8080/goodbye
	http://localhost:8080/hello

Creating a Pyramid Project:
	source ~/devenv/bin/activate
# Create new project
	paster create -t pyramid_routesalchemy MyProject
# Make sure from now on your working directory is your project folder: MyProject
	cd MyProject
# Install new project for development, this will install a distribution into the python interpreter's library.
	python setup.py develop
# Run test case, the tests are in MyProject/myproject/tests.py
	python setup.py test -q
# Interactive shell, "MyProject" here is the value of section name "app" in development.ini file, see more about pshell in pyramid docs.
	paster pshell development.ini MyProject
# Running the project application
	paster serve development.ini
	OR for development phase:
	paster serve development.ini --reload
	OR for production phase:
	paster serve production.ini
# tar your application:
	python setup.py sdist
	This will tar a .tar.gz file for your application, and make sure all the non-python file types are in your MANIFEST.in file, otherwise, the tar will miss these unspecified file types.
# Modifying Package Structure:
	You can create a new package for example "blog" under "myproject" folder and "cp views.py blog/views.py", and change the "myproject/__init__.py"
	from:
	config.add_view('myproject.views.my_view', renderer='myproject:templates/mytemplate.pt')
	to:
	config.add_view('myproject.views.blog.my_view', renderer='myproject:templates/mytemplate.pt')
# myproject/__init__.py:main function:
	def main(global_config, **settings=settings):
		config = Configurator(root_factory = Root, settings = settings)
		// blablabla
	if you have a "[DEFAULT]" section in development.ini, "global_config" here stores all the key/values pairs in "[DEFAULT]" section.
	"settings" here stores all the key/values pairs in "[app.MyProject]" section in development except one: "use = egg:MyProject"
	 you can put anything you want here into "settings" and access it later from "view callable" by invoking request.registry.setting dictionary at application runtime.

URL dispatch:
	1. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	from myproject.views import myview
	config.add_route('myroute', '/prefix/{one}/{two}', view=myview)
	2. "config" below is presumed to be an instance of the pyramid.config.Configurator class; "myview" is assumed to be a "view callable" function
	config.add_route('myroute', '/prefix/{one}/{two}', view='myproject.views.myview')
# Route pattern syntax:

	pattern: {foo}/bar/baz equals to /{foo}/bar/baz, the slash wil be prepended automatically anyway.

	pattern: foo/{baz}/{bar}
	url: foo/1/2        -> {'baz':u'1', 'bar':u'2'}
	url: foo/abc/def    -> {'baz':u'abc', 'bar':u'def'}
	url: foo/1/2/        -> No match (trailing slash)
	url: bar/abc/def     -> First segment literal mismatch
	And the the matched dict will be availabe as "request.matchdic"

	pattern: foo/{name}.html
	url: /foo/biz.html  -> {'name':u'biz'}

	pattern: foo/{name}.{ext}
	url: /foo/biz.html  -> {'name':u'biz', 'ext':u'html'}

	regular expession pattern: {foo} is actually: {foo:[^/]+} by default so that a replacement markder don't need to be preceded by a / slash, you can also change it to {foo:\d+}

	regular expression pattern: foo/{bar}
	foo/La%20Pe%C3%B1a  -> {'bar':u'La Pe\xf1a'}
	The matchdict will be URL-decoded / UTF-8 decoded.

	If the pattern has a * in it, the name which follows it is considered a “remainder match”. A remainder match must come at the end of the pattern.
	Unlike segment replacement markers, it does not need to be preceded by a slash. For example:
	regular expression pattern: foo/{baz}/{bar}*fizzle
	foo/1/2/           ->	{'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  ->	{'baz':u'abc', 'bar':u'def', 'fizzle':(u'a', u'b', u'c')}

	regular expression way to the similar things for above:
	foo/{baz}/{bar}{fizzle:.*}
	foo/1/2/           -> {'baz':u'1', 'bar':u'2', 'fizzle':()}
	foo/abc/def/a/b/c  -> {'baz':u'abc', 'bar':u'def', 'fizzle': u'a/b/c')}
	This occurs because the default regular expression for a marker is [^/]+ which will match everything up to the first /, while {fizzle:.*} will result in a regular expression match of .* capturing the
remainder into a single value.

# Route Declaration Ordering:
	memebers/{def}
	memebers/abc
	The "memebers/abc" will never be matched, since the ordering will always match the members/{def} first.

# Custom Route Predicates

	info['match'] is useful when predicates need access to the route match. For example:

	def any_of(segment_name, *allowed):
	    def predicate(info, request):
	        if info['match'][segment_name] in allowed:
	            return True
	    return predicate
	num_one_two_or_three = any_of('num', 'one', 'two', 'three')
	config.add_route('num', '/{num}', custom_predicates=(num_one_two_or_three,))
	
	This will ensure the "num" segment here is one of the values one, two or three.

	info['route'] is an object has two useful attributes: name and pattern
	1  def twenty_ten(info, request):
	2      if info['route'].name in ('ymd', 'ym', 'y'):
	3          return info['match']['year'] == '2010'
	4
	5  config.add_route('y', '/{year}', custom_predicates=(twenty_ten,))
	6  config.add_route('ym', '/{year}/{month}', custom_predicates=(twenty_ten,))
	7  config.add_route('ymd', '/{year}/{month}/{day}',
	8                   custom_predicates=(twenty_ten,))
	The above predicate, when added to a number of route configurations ensures that the year match argument is ‘2010’ if and only if the route name is ‘ymd’, ‘ym’, or ‘y’.

# The Matched Route
	The matched route is availabe as "request.matched_route", the useful attribute of this object is the "name" attribute, if no route url pattern matches, request.matched_route is None.

# Route Examples:
	Example 3:
	An example of using a route with a factory:
	config.add_route('idea', 'ideas/{idea}', view='myproject.views.idea_view', factory='myproject.resources.Idea')
	The above route will manufacture an Idea resource as a context, assuming that mypackage.resources.Idea resolves to a class that accepts a request in its __init__. For example:
	class Idea(object):
		def __init__(self, request):
			pass
	In a more complicated application, this root factory might be a class representing a SQLAlchemy model.
	
	Example 4:
	config.add_route('idea', 'site/{id}')
	config.add_view(route_name='idea', view='mypackage.views.site_view')
	are same to
	config.add_route('idea', 'site/{id}', view='mypackage.views.site_view')

# Matching the Root URL
	config.add_route('root', '', view='mypackage.views.root_view')
	Or provide the literal string / as the pattern:
	config.add_route('root', '/', view='mypackage.views.root_view')

# Generating Route URLs

	If you’ve configured a route with the name “foo” and the pattern “{a}/{b}/{c}”, you might do this.

	1 from pyramid.url import route_url
	2 url = route_url('foo', request, a='1', b='2', c='3')

	This would return something like the string http://example.com/1/2/3 (at least if the current protocol and hostname implied http:/example.com).

# Redirecting to Slash-Appended Routes
	config.add_route('hasslash', 'has_slash/', view='myproject.views.has_slash')
	config.add_view(context='pyramid.exceptions.NotFound', view='pyramid.view.append_slash_notfound_view')

	This will make sure the url path like "/has_slash" to be redirect to "/has_slash/"

	If still, when it can't redirect to a slash-appended url, it will go to 404 not found page. In this case, if you want to custom not found view when it can't redirect to a slash-appended url, do this:

	from pyramid.exceptions import NotFound
	from pyramid.view import AppendSlashNotFoundViewFactory

	def notfound_view(context, request):
		return HTTPNotFound('It aint there, stop trying!')

	custom_append_slash = AppendSlashNotFoundViewFactory(notfound_view)
	config.add_view(custom_append_slash, context=NotFound)

# Cleaning Up After a Request:
	
	In mypackage.__init__ module:

	from mypackage.models import DBSession

	from pyramid.events import subscriber
	from pyramid.events import NewRequest

	def cleanup_callback(request):
		DBSession.remove()

	@subscriber(NewRequest)
	def add_cleanup_callback(event):
		event.request.add_finished_callback(cleanup_callback)

	And make sure pyramid.config.Configurator.scan() is called since we have @subscriber here.

# Using Pyramid Security With URL Dispatch
	allow the editor the view permission:
	class Article(object):
		def __init__(self, request):
		   matchdict = request.matchdict
		   article = matchdict.get('article', None)
		   if article == '1':
			   self.__acl__ = [ (Allow, 'editor', 'view') ]

# Debugging Route Matching
	jiawzhang@home-pc:~$ PYRAMID_DEBUG_ROUTEMATCH=true paster server development.ini

# Displaying All Application Routes
	jiawzhang@home-pc:~$ paster proutes development.ini MyProject













# Activate virtual python env first:
# source ~/mydevenv/bin/activate
#
# To create a new project named helloword and running it:
# $ paster create -t pylons StudyPylons
# cd StudyPylons
# $ paster serve --reload development.ini
# Visiting http://127.0.0.1:5000/ to see welcome page.
#
# To create a controller, this will produce a module which is located at studypylons/controllers/hello.py:
# $ paster controller hello
# Visiting http://127.0.0.1:5000/hello/index
#
# For SQLAlchemy:
#     0. "service mysql status" to make sure mysql is running.
#     1. Make sure you log into mysql console and run "CREATE DATABASE studypylons DEFAULT CHARACTER SET utf8;" first, and if it's a mysql on amazon ec2, 3306 port on ec2 should be exposed for outsider.
#     2. vi development.ini to add mysql db url.
#     3. Put model classes like person.py, address.py into studypylons/model/
#     4. Run "paster setup-app development.ini" to create the tables in the database, this command will call studypylons/websetup.py
#     5. Run "paster serve --reload development.ini"
# Visiting http://127.0.0.1:5000/person/index to see a sample for SQLAlchemy
#
# For unit testing:
# Run "nosetests" in "StudyPylons" folder to start unit testing, it will automatically run the test case in StudyPylons/studypylons/tests
#
# Using the model standalone:
# % python
# Python 2.5.1 (r251:54863, Oct 5 2007, 13:36:32)
# [GCC 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)] on linux2
# Type "help", "copyright", "credits" or "license" for more information.
# >>> import sqlalchemy as sa
# >>> engine = sa.create_engine("sqlite:///test.sqlite")
# >>> from studypylons.model import init_model, Person
# >>> from studypylons.model.meta import Session, Base
# >>> init_model(engine)
# >>> a = Person()
# >>> a.name = "Aaa"
# >>> a.email = "aaa@example.com"
# >>> Session.add(a)
# >>> Session.commit()
#
# For Generating the Production Configuration
# paster make-config studypylons production.ini
#
# Put set-up once objects for the entire application to config/environment.py or lib/app_globals __init__() method.
#
# Put custom middleware to config/middleware.py at comment marker:
# # CUSTOM MIDDLEWARE HERE (filtered by error hanlding middlewares)
#
# StudyPylons is a standard Python package which contains setup.py where defines the package dependencies
# To re-parse the setup.py line for new dependencies, run "$ python setup.py develop"
#
